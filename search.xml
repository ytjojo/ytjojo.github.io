<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F09%2F%E5%90%8C%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%BAgitlab%E5%92%8Cgithub%E6%B7%BB%E5%8A%A0ssh%20key%2F</url>
    <content type="text"><![CDATA[title: 同一台电脑为gitlab和github添加ssh keydate: 2018-04-09 10:06:00categories: http tags: [ssh,ssh config]生成github ssh key12ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &quot;github邮箱&quot; 把公钥添加进github账户生成 gitlab ssh key 12ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitlab -C &quot;gitlab邮箱&quot; 把公钥添加进gitlab仓库验证是否添加成功 ssh -T git@github.com ssh -T gitlab@gitlab.com 在用户.ssh目录下如C:\Users\Administrator.ssh新建文件名为config的文件把下面复制进去，邮箱替换自己的 12345678Host gitlab.ngarihealth.com IdentityFile ~/.ssh/id_rsa.gitlab User yangtj@ngarihealth.com Host github.com IdentityFile ~/.ssh/id_rsa.github User ytjojo@163.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[git利用sparsecheckout上传apk文件]]></title>
    <url>%2F2018%2F04%2F08%2Fgit%E5%88%A9%E7%94%A8sparsecheckout%E4%B8%8A%E4%BC%A0apk%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[关键点 Conditional setps(multiple)插件使用 根据版本号和服务器环境制定保存目录 sparsecheckout制定checkout文件夹提升效率。 缺点很明显，初始化仓库很慢这只是一个初步的方案，写这篇文章目的只是简单记录，并不推荐使用 参数化构建参数化构建选择 Boolean ParameterName 填 uploadApkToGitLab Conditional setps(multiple)run？中选择Boolean conditionToken 填${uploadApkToGitLab}表示是否勾选上传git仓库 add step to condition点击add step to condition 选择 execute shell gitlab@gitlab.ngarihealth.com:yangtengjiao/doctorApks.git 是我的保存apk文件的git 仓库重复上传同一个文件夹内历史记录会被清空，防止历史记录太大，pull的时候消耗时间过长。利用sparsecheckout只checkout或者push指定的目录，这样效率会大大提升。填入shell命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 根据服务器环境来决定放在那个文件夹里。if [ &quot;$NGR_ENVIR&quot; == Test ];thenchildDir=releasefiif [ &quot;$NGR_ENVIR&quot; == PreRelease ];thenchildDir=prereleasefiif [ &quot;$NGR_ENVIR&quot; == Release ];thenchildDir=masterfi#这只有测试版 预发布和正式版才会上传git仓库 ，其他服务器环境childDir是空值，直接退出if [ ! $childDir ]; then echo &quot;childDir IS NULL&quot; exit 0else echo &quot;NOT NULL&quot;fi if [ ! -d &quot;$WORKSPACE/doctorApks&quot; ]; then mkdir $WORKSPACE/doctorApksficd doctorApks#根据版本号来决定父文件夹apkDir=$APP_VERSION_NAME&quot;_&quot;$APP_VERSION_CODEgit init git config core.sparsecheckout true #开启sparse clone 这是关键git config --global user.email &quot;yanttj@ngarihealth.com&quot;#这个已经要填，不然会报错git config --global user.name &quot;yangtj&quot;echo &quot;$&#123;apkDir&#125;&quot; &gt;&gt; .git/info/sparse-checkout #设置需要pull的目录，*表示所有，!表示匹配相反的git remote add -f origin gitlab@gitlab.ngarihealth.com:yangtengjiao/doctorApks.gitgit pull origin master #更新#删除历史记录git filter-branch --force --index-filter &quot;git rm --cached -r --ignore-unmatch $apkDir/$childDir&quot; --prune-empty --tag-name-filter cat -- --all#删除 历史记录后上传git push --force --allrm -rf .git/refs/original/git reflog expire --expire=now --all# 回收git垃圾git gc --prune=nowgit gc --aggressive --prune=nowif [ ! -d &quot;$WORKSPACE/doctorApks/$apkDir/$childDir&quot; ]; then mkdir $WORKSPACE/doctorApks/$apkDir/$childDirfi# 将新生成的apk文件复制到git仓库中制定目录下cp $WORKSPACE/buildApks/*.apk $WORKSPACE/doctorApks/$apkDir/$childDircp $WORKSPACE/buildApks/*.txt $WORKSPACE/doctorApks/$apkDir/$childDirgit add .git commit -m &quot;提交的描述信息&quot;# 上传apkgit push origin master]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>shell</tag>
        <tag>sparsecheckout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在subModule的仓库目录下build.gradle执行shell结果是外层仓库的错误解决方法]]></title>
    <url>%2F2018%2F04%2F04%2F%E5%9C%A8subModule%E7%9A%84%E4%BB%93%E5%BA%93%E7%9B%AE%E5%BD%95%E4%B8%8Bbuild.gradle%E5%BC%A0%E6%89%A7%E8%A1%8Cshell%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A4%96%E5%B1%82%E4%BB%93%E5%BA%93%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在build.gradle 获取当前仓库hash值rootProject是一个仓库工程子目录是另外一个git仓库，是android工程的一个module网上给出的代码很简单12345def getGitVersion() &#123; return 'git rev-parse --short HEAD'.execute().text.trim()&#125; 但是工程中git 仓库嵌套 或者有submodule 的时候在内部git仓库中的build.gradle添加上面的方法，结果发现是外部git仓库的结果 原来默认git shell 执行的工作空间是rootProject的磁盘空间，执行shell的时候要传入shell执行目录代码如下123 String parent = rootProject.rootDir.absolutePath.replaceAll('\\\\','/') def workingDir = new File(parent,"yourmodulename")return 'git rev-parse --short HEAD'.execute(null,workingDir).text.trim() 获取本地所有分支和获取所有Tag1234567891011def getGitBranch() &#123; String parent = rootProject.rootDir.absolutePath.replaceAll(&apos;\\\\&apos;,&apos;/&apos;) def workingDir = new File(parent,&quot;yourmodulename&quot;) return &apos;git rev-parse --short --symbolic --branches&apos;.execute(null,workingDir).text.trim()&#125;def getGitTag() &#123; String parent = rootProject.rootDir.absolutePath.replaceAll(&apos;\\\\&apos;,&apos;/&apos;) def workingDir = new File(parent,&quot;yourmodulename&quot;) return &apos;git rev-parse --short --symbolic --tags&apos;.execute(null,workingDir).text.trim()&#125; android工程无脑添加module正常添加module都是这样的 include ‘:app’include ‘:Library’如果你想无脑添加本地所有module在setting.gradle添加如下代码 12345678910111213141516171819def projectDir = getSettingsDir() as FileFile[] files = projectDir.listFiles()files.each &#123; println "it.name ::::::: "+it.name+":::::::" if(it.isDirectory() &amp;&amp; it.name.contains("ngr_"))&#123; def moduleName = it.name; it.listFiles(new FileFilter() &#123; @Override boolean accept(File file) &#123; return file.name.equals("build.gradle") &#125; &#125;).each &#123; println(moduleName+"setting---------") include(":"+moduleName) &#125; &#125;&#125;]]></content>
      <categories>
        <category>build.gradle执行shell</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>build.gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[retrofitex中错误处理，利用Rxjava2一行代码实现线程切换，失败重试，错误包装，在onDestroy反注册Observable]]></title>
    <url>%2F2018%2F04%2F04%2Fretrofitex%E4%B8%AD%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%8C%E5%88%A9%E7%94%A8Rxjava2%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%8C%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%EF%BC%8C%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85%EF%BC%8C%E5%9C%A8onDestroy%E5%8F%8D%E6%B3%A8%E5%86%8CObservable%2F</url>
    <content type="text"><![CDATA[开源库https://github.com/ytjojo/androidPractice/tree/master/retrofitex这是用与商业项目的Retrofit扩展库，最大亮点是支持自定义注解支持带进度的上传下载，多线程断点下载，支持cookie管理，支持token自动刷新（刷新条件可以根据http statucode 默认401 我们公司是403），token失效http status code 为 403 retrofit是不支持自动刷新token或者cookie的。支持错误重试支持post请求缓存，可以设置过期时间，支持无网络返回缓存。对https做了封装对https 在4.4及一下手机做了兼容。4.4手机下载或者上传图片的时候会出现如下错误 javax.net.ssl.SSLHandshakeException: javax.net.ssl.SSLProtocolException: SSL handshake aborted:支持在单元测试请求接口，这样验证新接口不用跑在手机上，当然用Postman更好封装RxBus，支持tag，post的时候可以指定标签，只有注册该标签才能收到，还支持最后一个注册者才能收到事件，在多个注册者但是只允许最后一个响应的时候特别有用。 错误重试错误重试是用retryWhen操作符还要根据不同的错误类型是重试或者直接回调OnError目前需要重试的异常有retrofit2.HttpExceptionConnectExceptionSocketTimeoutExceptionTimeoutExceptionUnknownHostException EOFException需要重新登录的异常有AuthExceptionTokenInvalidException这两个异常都是继承自RuntimeExceptin TokenInvalidException是在okHttp 拦截器中Http status code 401和403 409时候抛出的。 异常是在类com.ytjojo.http.interceptor.HeaderInterceptor抛出的;HeaderInterceptor发现Http status code 为401或者用户决定的code（我们项目中403或者409）之后，调用HeaderCallable的call()方法尝试刷新token，在这里是同步的网络请求，一般是登录接口。如果刷新失败则会抛出AuthException 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static Function&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt; getRetryFunc1() &#123; return new Function&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt;() &#123; private int retryDelaySecond = 5; private int retryCount = 0; private int maxRetryCount = 2; @Override public Observable&lt;?&gt; apply(Observable&lt;? extends Throwable&gt; observable) &#123; return observable.flatMap(new Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Throwable throwable) &#123; return checkApiError(throwable); &#125; &#125;); &#125; private Observable&lt;?&gt; checkApiError(Throwable throwable) &#123; retryCount++; if (retryCount &lt;= maxRetryCount) &#123; if (throwable instanceof ConnectException || throwable instanceof SocketTimeoutException || throwable instanceof TimeoutException || throwable instanceof UnknownHostException || throwable instanceof EOFException) &#123; return retry(throwable); &#125; else if (throwable instanceof AuthException) &#123; login(); return Observable.error(HttpExceptionHandle.handleException(throwable)); &#125; else if (throwable instanceof TokenInvalidException) &#123; login(); return Observable.error(HttpExceptionHandle.handleException(throwable)); &#125; if (throwable instanceof HttpException) &#123; HttpException he = (HttpException) throwable; if (he.code() != 401 &amp;&amp; he.code() != 403 &amp;&amp; he.code() != 409) &#123; return Observable.error(HttpExceptionHandle.handleException(throwable)); &#125;else &#123; return retry(throwable); &#125; &#125; return Observable.error(HttpExceptionHandle.handleException(throwable)); &#125;else&#123; if (throwable instanceof HttpException) &#123; HttpException he = (HttpException) throwable; if (he.code() == 401 || he.code() == 403 || he.code() == 409) &#123; login(); &#125; &#125; return Observable.error(HttpExceptionHandle.handleException(throwable)); &#125; &#125; /** * * @param throwable * @return */ private Observable&lt;?&gt; retry(Throwable throwable) &#123; if (retryCount &lt;= maxRetryCount) &#123; return Observable.timer(retryDelaySecond, TimeUnit.SECONDS).observeOn(Schedulers.io()); &#125; else &#123; return Observable.error(throwable); &#125; &#125; private void login() &#123; if(sOnErrorLoginCallback != null)&#123; sOnErrorLoginCallback.onErrorLogin(OnErrorLoginCallback.INTENT_FLAG); &#125; &#125; &#125;; &#125; 使用 123observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()).retryWhen(getRetryFunc1()) 拦截器如何刷新token和抛出TokenInvalidException AuthException这两个异常的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public class HeaderInterceptor implements Interceptor &#123; private static final Charset UTF8 = Charset.forName("UTF-8"); private final Map&lt;String, String&gt; mHeaders = new ConcurrentHashMap&lt;&gt;(); private final HeaderCallable mTokenCallable; private final CountDownLatch mCountDownLatch = new CountDownLatch(1); private final String baseUrl; AtomicInteger mRefreshTokenFlag = new AtomicInteger(0); volatile boolean restoreCachedValue; public void putHeader(String key, String value) &#123; if (key != null &amp;&amp; value != null) mHeaders.put(key, value); &#125; public void putHeaders(HashMap&lt;String, String&gt; headers) &#123; if (headers != null) &#123; mHeaders.putAll(headers); &#125; &#125; public void onUserLoginGetToken(String key, String token) &#123; mRefreshTokenFlag.set(0); if (key != null &amp;&amp; token != null) &#123; mHeaders.put(key, token); &#125; &#125; public HeaderInterceptor(HeaderCallable tokenCallable, String baseUrl) &#123; this.mTokenCallable = tokenCallable; this.baseUrl = baseUrl; &#125; void clearAuth() &#123; mHeaders.clear(); &#125; void processAuth() throws AuthException &#123; try &#123; String value = mTokenCallable.call(); if (value != null) &#123; mHeaders.put(mTokenCallable.key(), value); HashMap&lt;String, String&gt; extraHeaders = mTokenCallable.extraHeaders(); if (extraHeaders != null &amp;&amp; !extraHeaders.isEmpty()) &#123; mHeaders.putAll(extraHeaders); &#125; &#125; else &#123; throw new AuthException("HeaderCallable.call()获得的headervalue为null"); &#125; &#125; catch (Exception e) &#123; throw new AuthException(e); &#125; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; final Request request = chain.request(); if (request.url().toString().startsWith(baseUrl)) &#123; Response response = chain.proceed(updateHeadaerIfNeeded(chain)); if (isTokenExpired(response)) &#123; //token 已经失效了 if (mTokenCallable != null) &#123; //判断是否已经刷新了header String oldTokenValue = request.header(mTokenCallable.key()); if (mRefreshTokenFlag.compareAndSet(2, 0)) &#123; if (oldTokenValue != null &amp;&amp; oldTokenValue.equals(mHeaders.get(mTokenCallable.key()))) &#123; //已经更新了header,但是服务器仍然验证失败 throw new TokenInvalidException(response.code(),response.message()); &#125; &#125; requestTokenAync(); &#125; final Request.Builder requestBuilder = request.newBuilder(); for (HashMap.Entry&lt;String, String&gt; entry : mHeaders.entrySet()) &#123; String key = entry.getKey(); String value = entry.getValue(); if (value != null &amp;&amp; key != null) &#123; requestBuilder.header(key, value); &#125; &#125; Request newSigned = requestBuilder.build(); response = chain.proceed(newSigned); if(isTokenExpired(response))&#123; throw new TokenInvalidException(response.code(),response.message()); &#125; &#125; else &#123; return response; &#125; &#125; return chain.proceed(request); &#125; public static boolean equals(Object o1, Object o2) &#123; if (o1 == null || o2 == null) &#123; return false; &#125; return o1.equals(o2); &#125; private void requestTokenAync() throws IOException &#123; if (mRefreshTokenFlag.compareAndSet(0, 1)) &#123; clearAuth(); try &#123; processAuth(); mRefreshTokenFlag.set(2); &#125; catch (AuthException e) &#123; mRefreshTokenFlag.set(3); throw e; &#125; catch (Exception e) &#123; mRefreshTokenFlag.set(3); throw new AuthException(e); &#125; finally &#123; mCountDownLatch.countDown(); &#125; &#125; else if (mRefreshTokenFlag.compareAndSet(1, 1)) &#123; try &#123; mCountDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public Request updateHeadaerIfNeeded(Chain chain) throws IOException &#123; Request request = chain.request(); if (mHeaders.isEmpty()) &#123; return request; &#125; final Request.Builder requestBuilder = request.newBuilder(); if (mTokenCallable != null &amp;&amp; !restoreCachedValue) &#123; synchronized (HeaderInterceptor.class) &#123; if (!restoreCachedValue) &#123; if (mHeaders.get(mTokenCallable.key()) == null) &#123; String cachedValue = mTokenCallable.getCachedValue(); if (cachedValue != null) &#123; mHeaders.put(mTokenCallable.key(), cachedValue); &#125; &#125; restoreCachedValue = true; &#125; &#125; &#125; for (HashMap.Entry&lt;String, String&gt; entry : mHeaders.entrySet()) &#123; String key = entry.getKey(); String value = entry.getValue(); if (value != null &amp;&amp; key != null) &#123; requestBuilder.header(key, value); &#125; &#125; return requestBuilder.build(); &#125; private boolean isTokenExpired(Response originalResponse) &#123; if (originalResponse.code() == 401) &#123; return true; &#125; if (mTokenCallable != null) &#123; return mTokenCallable.isExpired(originalResponse.code(), originalResponse); &#125;// ResponseBody responseBody = originalResponse.body();// BufferedSource source = responseBody.source();// source.request(Long.MAX_VALUE); // Buffer the entire body.// Buffer buffer = source.buffer();// Charset charset = UTF8;// MediaType contentType = responseBody.contentType();// if (contentType != null) &#123;// charset = contentType.charset(UTF8);// &#125;// String bodyValue = buffer.clone().readString(charset);//// JSONObject jsonObject = new JSONObject(bodyValue);// int code = jsonObject.optInt("code");// if(code == ServerResponse.EXCEPTION_TOKEN_NOTVALID)&#123;// return true;// &#125; return false; &#125;&#125; 配置刷新token的HeaderCallable12345678910111213141516171819202122232425262728293031323334353637383940414243444546RetrofitClient.Builder builder = RetrofitClient.newBuilder().baseUrl(BuildConfig.ENVIRONMENT.getHostUrl()) .cache(new File(getContext().getCacheDir(), "cachehttp")) .showLog(isDebug) .addConverterFactory(JacksonConverterFactory.create(JsonParse.getInstance().jsonMapper())) .mergeParameterHandler(NgariParamHandlar.create()) .unsafeSSLSocketFactory() .headerCallable(new HeaderCallable() &#123; String token = null; @Override public String key() &#123; return LoginSdk.KEY_ACCESS_TOKEN; &#125; @Override public boolean isExpired(int code, Response response) &#123; return code == 403 || code == 409; &#125; @Override public String getCachedValue() &#123; return LoginSdk.getInstance().getToken(); &#125; @Override public HashMap&lt;String, String&gt; extraHeaders() &#123; return null; &#125; @Override public String call() throws Exception &#123; LoginSdk.getInstance().refreshToken().subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; token = s; &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable e) throws Exception &#123; &#125; &#125;); return token; &#125; &#125;); RetrofitClient.init(builder); 对错误信息的包装后台接口返回错误信息有的包含“server error” “HeibernateExceptrion” “DaoException”,我们toast提示是不希望看到这些异常信息的，需要替换为中文，如“跟服务器的交互发生点小问题，请重试..”，处理代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public class HttpExceptionHandle &#123; private static final int UNAUTHORIZED = 401; private static final int FORBIDDEN = 403; private static final int NOT_FOUND = 404; private static final int REQUEST_TIMEOUT = 408; private static final int REQUEST_CONFLICT = 409; private static final int INTERNAL_SERVER_ERROR = 500; private static final int BAD_GATEWAY = 502; private static final int SERVICE_UNAVAILABLE = 503; private static final int GATEWAY_TIMEOUT = 504; public static ResponeThrowable handleException(Throwable e) &#123; ResponeThrowable ex; Log.i("tag", "e.toString = " + e.toString()); if (e instanceof HttpException) &#123; HttpException httpException = (HttpException) e; switch (httpException.code()) &#123; case UNAUTHORIZED: case FORBIDDEN: case REQUEST_CONFLICT: ex = new ResponeThrowable("登录信息已经过期，请重新登陆...", e, ERROR.TOKEN_ERROR); break; case NOT_FOUND: case REQUEST_TIMEOUT: case GATEWAY_TIMEOUT: case INTERNAL_SERVER_ERROR: case BAD_GATEWAY: case SERVICE_UNAVAILABLE: default: ex = new ResponeThrowable("网络错误", e, ERROR.HTTP_ERROR); //ex.code = httpException.code(); break; &#125; return ex; &#125; else if (e instanceof APIException) &#123; ex = new ResponeThrowable(e.getMessage(), e, ((APIException) e).code); return ex; &#125; else if (e instanceof ConnectException || e instanceof SocketTimeoutException || e instanceof TimeoutException || e instanceof UnknownHostException || e instanceof EOFException ) &#123; ex = new ResponeThrowable("网络无法连接", e, ERROR.NETWORD_ERROR); return ex; &#125; else if (e instanceof javax.net.ssl.SSLHandshakeException) &#123; ex = new ResponeThrowable("证书验证失败", e, ERROR.SSL_ERROR); return ex; &#125; else if (e instanceof TokenInvalidException) &#123; ex = new ResponeThrowable("登录信息已经过期，请重新登陆...", e.getCause(), ERROR.TOKEN_ERROR); return ex; &#125; else if (e instanceof AuthException) &#123; ex = new ResponeThrowable("登录信息已经过期，请重新登陆...", e.getCause(), ERROR.AUTH_ERROR); return ex; &#125; else &#123; String className =e.getClass().getName().toLowerCase(); if (className.contains("json")) &#123; ex = new ResponeThrowable("解析错误", e, ERROR.PARSE_ERROR); return ex; &#125; ex = new ResponeThrowable("跟服务器的交互发生点小问题，请重试..", e.getCause() == null ? e : e.getCause(), ERROR.UNKNOWN); return ex; &#125; &#125; /** * 约定异常 */ public static final class ERROR &#123; /** * 未知错误 */ public static final int UNKNOWN = 1000; /** * 解析错误 */ public static final int PARSE_ERROR = 1001; /** * 网络错误 */ public static final int NETWORD_ERROR = 1002; /** * 协议出错 */ public static final int HTTP_ERROR = 1003; /** * 证书出错 */ public static final int SSL_ERROR = 1005; /** * 证书出错 */ public static final int TOKEN_ERROR = 1006; /** * 证书出错 */ public static final int AUTH_ERROR = 1007; &#125; public static class ResponeThrowable extends RuntimeException &#123; public int code; public ResponeThrowable(String message, Throwable throwable, int code) &#123; super(message, throwable); this.code = code; &#125; &#125;&#125; 一行代码实现线程切换失败重试异常封装，onDestroy()反注册Obaservable用compose操作符，传入RxHttpHelper中创建的ObservableTransformer 1234567 RetrofitClient.getDefault().create(TransferService.class) .updateTransferStatusToHaveClinic(mTransfer.getTransferId())//下面一行代码实现上述功能 .compose(RxHttpHelper.applySchedulers(TransferDetailActivity.this .&lt;Boolean&gt;bindUntilEvent(ActivityEvent.DESTROY))) .subscribe() RxHttpHelper完整源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public static interface OnErrorLoginCallback&#123; public static final int INTENT_FLAG= Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP; void onErrorLogin(int defaultIntentFlag);&#125;private static OnErrorLoginCallback sOnErrorLoginCallback;public static void setOnErrorLoginCallback(OnErrorLoginCallback c)&#123; sOnErrorLoginCallback = c;&#125;public static Function&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt; getRetryFunc1() &#123; return new Function&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt;() &#123; private int retryDelaySecond = 5; private int retryCount = 0; private int maxRetryCount = 3; @Override public Observable&lt;?&gt; apply(Observable&lt;? extends Throwable&gt; observable) &#123; return observable.flatMap(new Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Throwable throwable) &#123; return checkApiError(throwable); &#125; &#125;); &#125; private Observable&lt;?&gt; checkApiError(Throwable throwable) &#123; retryCount++; if (retryCount &lt;= maxRetryCount) &#123; if (throwable instanceof ConnectException || throwable instanceof SocketTimeoutException || throwable instanceof TimeoutException || throwable instanceof UnknownHostException || throwable instanceof EOFException) &#123; return retry(throwable); &#125; else if (throwable instanceof AuthException) &#123; login(); return Observable.error(HttpExceptionHandle.handleException(throwable)); &#125; else if (throwable instanceof TokenInvalidException) &#123; login(); return Observable.error(HttpExceptionHandle.handleException(throwable)); &#125; if (throwable instanceof HttpException) &#123; HttpException he = (HttpException) throwable; if (he.code() != 401 &amp;&amp; he.code() != 403 &amp;&amp; he.code() != 409) &#123; return Observable.error(HttpExceptionHandle.handleException(throwable)); &#125;else &#123; return retry(throwable); &#125; &#125; return Observable.error(HttpExceptionHandle.handleException(throwable)); &#125;else&#123; if (throwable instanceof HttpException) &#123; HttpException he = (HttpException) throwable; if (he.code() == 401 || he.code() == 403 || he.code() == 409) &#123; login(); &#125; &#125; return Observable.error(HttpExceptionHandle.handleException(throwable)); &#125; &#125; /** * * @param throwable * @return */ private Observable&lt;?&gt; retry(Throwable throwable) &#123; if (retryCount &lt;= maxRetryCount) &#123; return Observable.timer(retryDelaySecond, TimeUnit.SECONDS).observeOn(Schedulers.io()); &#125; else &#123; return Observable.error(throwable); &#125; &#125; private void login() &#123; if(sOnErrorLoginCallback != null)&#123; sOnErrorLoginCallback.onErrorLogin(OnErrorLoginCallback.INTENT_FLAG); &#125; &#125; &#125;;&#125;public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; applySchedulers() &#123; return new ObservableTransformer&lt;T, T&gt;() &#123; @Override public ObservableSource&lt;T&gt; apply(Observable&lt;T&gt; observable) &#123; return observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()).retryWhen(getRetryFunc1()); &#125; &#125;;&#125;public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; applySchedulers(final LifecycleTransformer transformer, Class&lt;T&gt; tClass) &#123; return new ObservableTransformer&lt;T, T&gt;() &#123; @Override public Observable&lt;T&gt; apply(Observable&lt;T&gt; observable) &#123; return observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()).retryWhen(getRetryFunc1()).compose(transformer); &#125; &#125;;&#125;public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; applySchedulers(final LifecycleTransformer&lt;T&gt; transformer) &#123; return new ObservableTransformer&lt;T, T&gt;() &#123; @Override public Observable&lt;T&gt; apply(Observable&lt;T&gt; observable) &#123; return observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()).retryWhen(getRetryFunc1()).compose(transformer); &#125; &#125;;&#125;]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>错误处理</tag>
        <tag>失败重试</tag>
        <tag>线程切换</tag>
        <tag>compose操作符</tag>
        <tag>ObservableTransformer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[retrofitex中https的处理以及4.4一下手机不支持TLS的解决办法]]></title>
    <url>%2F2018%2F04%2F04%2Fretrofitex%E4%B8%ADhttps%E7%9A%84%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A4.4%E4%B8%80%E4%B8%8B%E6%89%8B%E6%9C%BA%E4%B8%8D%E6%94%AF%E6%8C%81TLS%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[开源库https://github.com/ytjojo/androidPractice/tree/master/retrofitex这是用与商业项目的Retrofit扩展库，最大亮点是支持自定义注解支持带进度的上传下载，多线程断点下载，支持cookie管理，支持token自动刷新（刷新条件可以根据http statucode 默认401 我们公司是403），token失效http status code 为 403 retrofit是不支持自动刷新token或者cookie的。支持错误重试支持post请求缓存，可以设置过期时间，支持无网络返回缓存。对https做了封装对https 在4.4及一下手机做了兼容。4.4手机下载或者上传图片的时候会出现如下错误 javax.net.ssl.SSLHandshakeException: javax.net.ssl.SSLProtocolException: SSL handshake aborted:支持在单元测试请求接口，这样验证新接口不用跑在手机上，当然用Postman更好封装RxBus，支持tag，post的时候可以指定标签，只有注册该标签才能收到，还支持最后一个注册者才能收到事件，在多个注册者但是只允许最后一个响应的时候特别有用。 前言在4.4手机上传和下载图片的时候发现无法上传，或者显示图片，经查错误信息如下 javax.net.ssl.SSLHandshakeException: javax.net.ssl.SSLProtocolException: SSL handshake aborted: ssl=0x79f145b0: Failure in SSL library, usually a protocol errorerror:1407742E:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert protocol version 原因：Android 4.4及以下的系统默认不支持TLS 1.1和TLS1.2 协议，后台使用的TLS协议的是1.1或者1.2客户端就会请求失败。 ProtocolSupported (API Levels)Enabled by default (API Levels)SSLv31+1+TLSv11+1+TLSv1.116+20+TLSv1.216+20+ TLSv1.0从API 1+就被默认打开 TLSv1.1和TLSv1.2只有在API 20+ 才会被默认打开 低于API 20+的版本是默认关闭对TLSv1.1和TLSv1.2的支持，若要支持则必须自己打开 解决方案就是根据当前版本支持的TSL版本，在创建socket的时候开启对应的版本的支持，但是服务器要全部支持1.0 、1.1和1.2，否则在低于16的android手机上即使客户端添加了代码还是不支持1.1和1.2的。参考文章https://blog.csdn.net/s003603u/article/details/53907910https://www.cnblogs.com/daquexian/p/5883585.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172public class SSLSocketFactoryCompat extends SSLSocketFactory &#123; private static volatile SSLSocketFactory defaultFactory; // Android 5.0+ (API level21) provides reasonable default settings // but it still allows SSLv3 // https://developer.android.com/about/versions/android-5.0-changes.html#ssl static String protocols[] = null, cipherSuites[] = null; static &#123; try &#123; SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket(); if (socket != null) &#123; /* set reasonable protocol versions */ // - enable all supported protocols (enables TLSv1.1 and TLSv1.2 on Android &lt;5.0) // - remove all SSL versions (especially SSLv3) because they're insecure now List&lt;String&gt; protocols = new LinkedList&lt;&gt;(); for (String protocol : socket.getSupportedProtocols()) if (!protocol.toUpperCase().contains("SSL")) protocols.add(protocol); SSLSocketFactoryCompat.protocols = protocols.toArray(new String[protocols.size()]); /* set up reasonable cipher suites */ if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; // choose known secure cipher suites List&lt;String&gt; allowedCiphers = Arrays.asList( // TLS 1.2 "TLS_RSA_WITH_AES_256_GCM_SHA384", "TLS_RSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", "TLS_ECHDE_RSA_WITH_AES_128_GCM_SHA256", // maximum interoperability "TLS_RSA_WITH_3DES_EDE_CBC_SHA", "TLS_RSA_WITH_AES_128_CBC_SHA", // additionally "TLS_RSA_WITH_AES_256_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"); List&lt;String&gt; availableCiphers = Arrays.asList(socket.getSupportedCipherSuites()); // take all allowed ciphers that are available and put them into preferredCiphers HashSet&lt;String&gt; preferredCiphers = new HashSet&lt;&gt;(allowedCiphers); preferredCiphers.retainAll(availableCiphers); /* For maximum security, preferredCiphers should *replace* enabled ciphers (thus disabling * ciphers which are enabled by default, but have become unsecure), but I guess for * the security level of DAVdroid and maximum compatibility, disabling of insecure * ciphers should be a server-side task */ // add preferred ciphers to enabled ciphers HashSet&lt;String&gt; enabledCiphers = preferredCiphers; enabledCiphers.addAll(new HashSet&lt;&gt;(Arrays.asList(socket.getEnabledCipherSuites()))); SSLSocketFactoryCompat.cipherSuites = enabledCiphers.toArray(new String[enabledCiphers.size()]); &#125; socket.close(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public SSLSocketFactoryCompat(X509TrustManager tm) &#123; try &#123; SSLContext sslContext = SSLContext.getInstance("TLS"); sslContext.init(null, (tm != null) ? new X509TrustManager[] &#123; tm &#125; : null, null); defaultFactory = sslContext.getSocketFactory(); &#125; catch (GeneralSecurityException e) &#123; throw new AssertionError(); // The system has no TLS. Just give up. &#125; &#125; public static SSLSocketFactoryCompat get(X509TrustManager tm) &#123; return new SSLSocketFactoryCompat(tm); &#125; static SSLSocketFactoryCompat sSSLSocketFactoryCompat; public static SSLSocketFactoryCompat get() &#123; if (sSSLSocketFactoryCompat == null) &#123; synchronized (SSLSocketFactoryCompat.class)&#123; if(sSSLSocketFactoryCompat == null)&#123; final X509TrustManager trustAllCert = new X509TrustManager() &#123; @Override public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123; return new java.security.cert.X509Certificate[]&#123;&#125;; &#125; &#125;; sSSLSocketFactoryCompat = get(trustAllCert); &#125; &#125; &#125; return sSSLSocketFactoryCompat; &#125; private void upgradeTLS(SSLSocket ssl) &#123; // Android 5.0+ (API level21) provides reasonable default settings // but it still allows SSLv3 // https://developer.android.com/about/versions/android-5.0-changes.html#ssl if (protocols != null) &#123; ssl.setEnabledProtocols(protocols); &#125; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP &amp;&amp; cipherSuites != null) &#123; ssl.setEnabledCipherSuites(cipherSuites); &#125; &#125; @Override public String[] getDefaultCipherSuites() &#123; return cipherSuites; &#125; @Override public String[] getSupportedCipherSuites() &#123; return cipherSuites; &#125; @Override public Socket createSocket() throws IOException &#123; Socket ssl = defaultFactory.createSocket(); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125; @Override public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException &#123; Socket ssl = defaultFactory.createSocket(s, host, port, autoClose); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125; @Override public Socket createSocket(String host, int port) throws IOException, UnknownHostException &#123; Socket ssl = defaultFactory.createSocket(host, port); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125; @Override public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException &#123; Socket ssl = defaultFactory.createSocket(host, port, localHost, localPort); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125; @Override public Socket createSocket(InetAddress host, int port) throws IOException &#123; Socket ssl = defaultFactory.createSocket(host, port); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125; @Override public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException &#123; Socket ssl = defaultFactory.createSocket(address, port, localAddress, localPort); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125; private Socket enableTLSOnSocket(Socket socket) &#123; if(socket != null &amp;&amp; (socket instanceof SSLSocket)) &#123; ((SSLSocket)socket).setEnabledProtocols(new String[] &#123;"TLSv1.1", "TLSv1.2"&#125;); &#125; return socket; &#125;&#125; 关键方法是 ssl.setEnabledProtocols(protocols)和ssl.setEnabledCipherSuites(cipherSuites); 每次创建SSLSocket时候都要调用上面两个方法 ###123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216public class HttpsDelegate &#123; private static volatile HttpsDelegate mInstance; private HttpsDelegate()&#123; &#125; public static HttpsDelegate getInstance() &#123; if(null == mInstance) &#123; synchronized (HttpsDelegate.class) &#123; if(null == mInstance) &#123; mInstance = new HttpsDelegate(); &#125; &#125; &#125; return mInstance; &#125; public static Pair&lt;SSLSocketFactory,X509TrustManager&gt; getUnsafeSslSocketFactory()&#123; return getSslSocketFactory(null,null,null); &#125; public static Pair&lt;SSLSocketFactory,X509TrustManager&gt; getUnsafeSslSocketFactory(InputStream[] certificates)&#123; return getSslSocketFactory(certificates,null,null); &#125; public static Pair&lt;SSLSocketFactory,X509TrustManager&gt; getSslSocketFactory(InputStream[] certificates, InputStream bksFile, String password) &#123; Pair&lt;SSLSocketFactory,X509TrustManager &gt; sslParams = null; try &#123; TrustManager[] trustManagers = prepareTrustManager(certificates); KeyManager[] keyManagers = prepareKeyManager(bksFile, password); SSLContext sslContext = SSLContext.getInstance("TLS"); X509TrustManager trustManager = null; if (trustManagers != null) &#123; trustManager = new MyTrustManager(chooseTrustManager(trustManagers)); &#125; else &#123; trustManager = new UnSafeTrustManager(); &#125; sslContext.init(keyManagers, new TrustManager[]&#123;trustManager&#125;,null); sslParams =new Pair&lt;&gt;(SSLSocketFactoryCompat.get(),trustManager); return sslParams; &#125; catch (NoSuchAlgorithmException e) &#123; throw new AssertionError(e); &#125; catch (KeyManagementException e) &#123; throw new AssertionError(e); &#125; catch (KeyStoreException e) &#123; throw new AssertionError(e); &#125; &#125; private static class UnSafeTrustManager implements X509TrustManager &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new java.security.cert.X509Certificate[]&#123;&#125;; &#125; &#125; private static TrustManager[] prepareTrustManager(InputStream... certificates) &#123; if (certificates == null || certificates.length &lt;= 0) return null; try &#123; CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509"); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null); int index = 0; for (InputStream certificate : certificates) &#123; String certificateAlias = Integer.toString(index++); keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate)); try &#123; if (certificate != null) certificate.close(); &#125; catch (IOException e) &#123; &#125; &#125; TrustManagerFactory trustManagerFactory = null; trustManagerFactory = TrustManagerFactory. getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); TrustManager[] trustManagers = trustManagerFactory.getTrustManagers(); return trustManagers; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private static KeyManager[] prepareKeyManager(InputStream bksFile, String password) &#123; try &#123; if (bksFile == null || password == null) return null; KeyStore clientKeyStore = KeyStore.getInstance("BKS"); clientKeyStore.load(bksFile, password.toCharArray()); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(clientKeyStore, password.toCharArray()); return keyManagerFactory.getKeyManagers(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnrecoverableKeyException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private static X509TrustManager chooseTrustManager(TrustManager[] trustManagers) &#123; for (TrustManager trustManager : trustManagers) &#123; if (trustManager instanceof X509TrustManager) &#123; return (X509TrustManager) trustManager; &#125; &#125; return null; &#125; private static class MyTrustManager implements X509TrustManager &#123; private X509TrustManager defaultTrustManager; private X509TrustManager localTrustManager; public MyTrustManager(X509TrustManager localTrustManager) throws NoSuchAlgorithmException, KeyStoreException &#123; TrustManagerFactory var4 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); var4.init((KeyStore) null); defaultTrustManager = chooseTrustManager(var4.getTrustManagers()); this.localTrustManager = localTrustManager; &#125; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; try &#123; defaultTrustManager.checkServerTrusted(chain, authType); &#125; catch (CertificateException ce) &#123; localTrustManager.checkServerTrusted(chain, authType); &#125; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125;&#125; 添加到OkhttpClient中123OkHttpClient.Builder builder;Pair&lt;SSLSocketFactory, X509TrustManager&gt; sslFactory =HttpsDelegate.getUnsafeSslSocketFactory() builder.sslSocketFactory(sslFactory.first, sslFactory.second);]]></content>
      <categories>
        <category>https</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>TSL</tag>
        <tag>SSLHandshakeException</tag>
        <tag>SSLSocketFactory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gson、Jackson与retrofit的结合，用泛型优雅处理服务器返回数据]]></title>
    <url>%2F2018%2F03%2F30%2FGson%E3%80%81Jackson%E4%B8%8Eretrofit%E7%9A%84%E7%BB%93%E5%90%88%EF%BC%8C%E7%94%A8%E6%B3%9B%E5%9E%8B%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[开源库https://github.com/ytjojo/androidPractice/tree/master/retrofitex这是用与商业项目的Retrofit扩展库，最大亮点是支持自定义注解支持带进度的上传下载，多线程断点下载，支持cookie管理，支持token自动刷新（刷新条件可以根据http statucode 默认401 我们公司是403），token失效http status code 为 403 retrofit是不支持自动刷新token或者cookie的。支持错误重试支持post请求缓存，可以设置过期时间，支持无网络返回缓存。对https做了封装对https 在4.4及一下手机做了兼容。4.4手机下载或者上传图片的时候会出现如下错误 javax.net.ssl.SSLHandshakeException: javax.net.ssl.SSLProtocolException: SSL handshake aborted:支持在单元测试请求接口，这样验证新接口不用跑在手机上，当然用Postman更好 前言服务器返回的json格式大多数是固定的，我们公司返回结果中，最外层字段是固定的，code body msg，其中code是int值，msg是返回的消息body则根据接口不同而不同，可以是基本数据类型，也可以是JsonObject 或者JsonArray。举个例子 123456789101112131415161718192021&#123; "code": 200, "body": 100000&#125;&#123; "code": 200, "body": "success"&#125;&#123; "code": 200, "body": [&#123;"name":"zhangsan","age":20&#125;,&#123;"name":"lisi","age":21&#125;]&#125;&#123; "code": 200, "body": &#123; "orderNum":1001, "date":"2014-12-10 22:33" &#125;&#125; 200表示接口正常返回（注意这个200是服务返回消息体的json中字段，不是http status code）。 用泛型统一返回对象123456789101112131415161718/** * Created by Administrator on 2016/10/18 0018. */public class ServerResponse&lt;T&gt; implements Serializable&#123; public static int RESULT_OK =200; public int code; public String msg; public T body; public ServerResponse(int code, String msg, T body)&#123; this.code =code; this.msg = msg; this.body = body; &#125; public ServerResponse()&#123; &#125;&#125; ` 实现需求1 可以只专注Body值，body不等于200走失败回调，error有失败的code和msg；2 支持整个返回结果，123456//支持任何java类型Observable&lt;AnyJavaEntry&gt; getResponse()Observable&lt;Integer&gt; getResponse()Observable&lt;String&gt; getResponse()Observable&lt;Boolean&gt; getResponse() Jackson 方式 12Observable&lt;JsonNode&gt; getArticles() Gson方式12@Get("url")Observable&lt;JsonElement&gt; getArticles() 3支持结果有额外字段 如果code body 同级有额外字段，只需要继承这个泛型类ServerResponse1234567public class ArticleResponse extends ServerResponse&lt;ArrayList&lt;Article&gt;&gt; &#123; public ArrayList&lt;String&gt; urls;&#125;//接口可以这样写，@Get("url")Observable&lt;ArticleResponse&gt; getArticles() 4 支持服务器不规范的返回结果如整个相应体为空,我们退出登录接口返回相应体为空，http status code 200 ，但是相应体不包含任何字符串，也没有当初约定的code body msg这些json字段。当然也是支持走成功回调的只需要把返回值写成Observable1Observable&lt;Object&gt; logout() 还有个接口返回的json只有200，{“code”:200},这个接口客户端是不需要结果的，只需要知道成功失败，后台的大佬直接给个这种json，我其实希望body有个boolean的但是后台不肯改，好吧那我这边就支持这种方式吧。方法也很简单1Observable&lt;Object&gt; closeChat() 5 后台接口body有时候返回null，但是Rxjava2出现java.lang.NullPointerException: Null is not a valid elementRxjava2 的onNext()必须不为null值，如果为null值，会走到OnError回调里去。解决方案是Observable request()替换为Observable&lt;ServerResponse&gt; request() 完整代码如下Jackson1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798final class JacksonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123; private final ObjectMapper mapper; private final Type type; public static Void DEFAULT_VOID_INSTIANCE; enum Irrelevant &#123; INSTANCE; &#125; JacksonResponseBodyConverter(Type type, ObjectMapper mapper) &#123; this.type = type; this.mapper = mapper; &#125; @Override public T convert(ResponseBody responseBody) throws IOException &#123; BufferedSource bufferedSource = Okio.buffer(responseBody.source()); String value = bufferedSource.readUtf8(); bufferedSource.close(); if (TextUtils.isEmpty(value)) &#123; if (type == Object.class) &#123; return (T) Irrelevant.INSTANCE; &#125; throw new APIException(0, "response is empty"); &#125; JsonNode responseNode = mapper.readTree(value); JsonNode codeJsonNode = responseNode.get("code"); JsonNode msgNode = responseNode.get("msg"); String msg = msgNode == null ? null : msgNode.asText(); int code = codeJsonNode != null ? codeJsonNode.asInt() : 0; if (codeJsonNode != null) &#123; if (code != 200) &#123; //这一步很关键 //如果接口返回code不是200，就会走onError， throw new APIException(codeJsonNode.asInt(), msg, value); &#125; &#125; else &#123; return parseNoCodeAndNoBodyType(responseNode, value); &#125; JavaType javaType = mapper.constructType(type); if (!javaType.isTypeOrSubTypeOf(ServerResponse.class)) &#123; if (type == String.class) &#123; JsonNode bodyNode = responseNode.get("body"); if (bodyNode == null) &#123; return (T) ""; &#125; if (bodyNode.isTextual()) &#123; return (T) bodyNode.asText(); &#125; return (T) mapper.writeValueAsString(bodyNode); &#125; if (type == Void.class) &#123; assertVoidInstance(); return (T) DEFAULT_VOID_INSTIANCE; &#125; if (type == JsonNode.class) &#123; return (T) responseNode; &#125; if (type == Object.class) &#123; return (T) Irrelevant.INSTANCE; &#125; JavaType responseType = mapper.getTypeFactory().constructParametrizedType( ServerResponse.class, ServerResponse.class, javaType); ServerResponse responseWrapper = mapper.readValue(value, responseType); return (T) responseWrapper.body; &#125; return mapper.readValue(value, javaType); &#125; private void assertVoidInstance() &#123; if (DEFAULT_VOID_INSTIANCE == null) &#123; Constructor&lt;?&gt;[] cons = Void.class.getDeclaredConstructors(); cons[0].setAccessible(true); try &#123; DEFAULT_VOID_INSTIANCE = (Void) cons[0].newInstance(new Object[]&#123;&#125;); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private T parseNoCodeAndNoBodyType(JsonNode root, String json) throws IOException &#123; if (type == Void.class) &#123; assertVoidInstance(); return (T) DEFAULT_VOID_INSTIANCE; &#125; if (type == JsonNode.class) &#123; return (T) root; &#125; if (type == Object.class) &#123; return (T) Irrelevant.INSTANCE; &#125; return mapper.readValue(json, mapper.constructType(type)); &#125;&#125; Gson123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123; public static Void DEFAULT_VOID_INSTIANCE; private final Gson mGson; private final Type type; private TypeAdapter&lt;T&gt; adapter; enum Irrelevant &#123; INSTANCE; &#125; GsonResponseBodyConverter(Gson gson, Type type) &#123; this.mGson = gson; this.type = type; &#125; @Override public T convert(ResponseBody responseBody) throws IOException &#123; BufferedSource bufferedSource = Okio.buffer(responseBody.source()); String value = bufferedSource.readUtf8(); bufferedSource.close(); if (TextUtils.isEmpty(value)) &#123; if(type == Object.class)&#123; return (T) Irrelevant.INSTANCE; &#125; //这一步很关键 //如果接口返回code不是200，就会走onError， throw new APIException(-3, "response is null"); &#125; int code = Integer.MAX_VALUE; JsonElement root = null; JsonObject response; try&#123; root = mGson.fromJson(value, JsonElement.class); if(root.isJsonObject())&#123; response = root.getAsJsonObject(); JsonElement codeElement = response.get("code"); if(codeElement != null)&#123; code = codeElement.getAsInt(); &#125;else &#123; JsonElement bodyJson = response.get("body"); if(bodyJson == null)&#123; return parse(root,value); &#125; &#125; &#125;else &#123; return parse(root,value); &#125; &#125;catch (Exception e)&#123; throw new JsonException("json解析失败",e); &#125; if (code != ServerResponse.RESULT_OK) &#123; JsonElement msgJE = response.get("msg"); String msg = msgJE == null ? null : msgJE.getAsString(); throw new APIException(code, msg, value); &#125; try&#123; if (type instanceof Class) &#123; if(type == EntireStringResult.class)&#123; return (T) new EntireStringResult(value); &#125; if (type == String.class) &#123; JsonElement bodyJson = response.get("body"); if(bodyJson ==null)&#123; return null; &#125; if(bodyJson.isJsonPrimitive())&#123; return (T) bodyJson.getAsString(); &#125; return (T)(mGson.toJson(bodyJson)); &#125; if (type == Object.class) &#123; return (T) Irrelevant.INSTANCE; &#125; if (type == Void.class) &#123; assertVoidInstance(); return (T) DEFAULT_VOID_INSTIANCE; &#125; if (type == JsonElement.class) &#123; //如果返回结果是JSONObject则无需经过Gson return (T)(root); &#125; if(!(ServerResponse.class.isAssignableFrom((Class&lt;?&gt;) type)))&#123; Type wrapperType = $Gson$Types.newParameterizedTypeWithOwner(null,ServerResponse.class,type); ServerResponse&lt;?&gt; wrapper = mGson.fromJson(value, wrapperType); return (T) wrapper.body; &#125; &#125; return mGson.fromJson(value, type); &#125;catch (Exception e)&#123; throw new JsonException("json解析失败",e); &#125; &#125; private void assertVoidInstance()&#123; if(DEFAULT_VOID_INSTIANCE ==null)&#123; Constructor&lt;?&gt;[] cons = Void.class.getDeclaredConstructors(); cons[0].setAccessible(true); try &#123; DEFAULT_VOID_INSTIANCE = (Void) cons[0].newInstance(new Object[]&#123;&#125;); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private T parse(JsonElement root,String json)&#123; if(type == EntireStringResult.class)&#123; return (T) new EntireStringResult(json); &#125; if (type == Object.class) &#123; return (T) Irrelevant.INSTANCE; &#125; if (type == Void.class) &#123; assertVoidInstance(); return (T) DEFAULT_VOID_INSTIANCE; &#125; if (type == JsonElement.class) &#123; //如果返回结果是JSONObject则无需经过Gson return (T)(root); &#125; return mGson.fromJson(json, type); &#125;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>gson</tag>
        <tag>json</tag>
        <tag>jackson</tag>
        <tag>retrofit</tag>
        <tag>Converter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Gson和Jackson的花式使用都在这里了，一网打尽Json转换]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%85%B3%E4%BA%8EGson%E5%92%8CJackson%E7%9A%84%E8%8A%B1%E5%BC%8F%E4%BD%BF%E7%94%A8%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86%EF%BC%8C%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BDJson%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[简单配置Gson12345GsonBuilder builder = new GsonBuilder();builder.enableComplexMapKeySerialization() .serializeNulls();builder.setDateFormat("yyyy-MM-dd HH:mm:ss");Gson gson = builder.create(); Jackson123456789101112131415161718ObjectMapper objectMapper = new ObjectMapper(); SimpleDateFormat fmt = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss"); objectMapper.setDateFormat(fmt); objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true); objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);//字段和值加引号 objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);//允许转义字符 objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);//允许单引号 objectMapper.configure(JsonParser.Feature. ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER, true);//允许反斜杠 objectMapper.configure(JsonParser.Feature. ALLOW_NUMERIC_LEADING_ZEROS, true);//允许数字00005 赋值为5； objectMapper.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true); objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false); objectMapper.setSerializationInclusion(JsonInclude.Include.ALWAYS); objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES,true); objectMapper.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, true); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); //该特性可以允许JSON空字符串转换为POJO对象为null,否则抛异常。空字符串不是标准的pojo对应的json objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT,true); 字段值为null系列化输出为nullGson123 GsonBuilder builder = new GsonBuilder(); builder.serializeNulls();Gson gson = builder.create(); Jackson12ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setSerializationInclusion(JsonInclude.Include.ALWAYS); 设置默认日期格式Gson12builder.setDateFormat("yyyy-MM-dd HH:mm:ss"); Jackson123SimpleDateFormat fmt = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss"); objectMapper.setDateFormat(fmt); 类级别上处理部分字段序列化和反序列化忽略两个框架都支持用transient修饰的字段忽略。 Gson处理方式，使用@Expose注解 1234567891011public class User &#123; @Expose public String firstName; @Expose(serialize = false) public String lastName; @Expose (serialize = false, deserialize = false) public emailAddress; public String password; public transient boolean isDeveloper &#125; Jackson 用@JsonIgnore用与字段 get Set方法， @JsonIgnoreProperties用于类json 、msg、status都会被忽略1234567891011@JsonIgnoreProperties(&#123;"msg","status"&#125;) public static class Body &#123; @JsonIgnore private String json; public String msg; public int status; public Body()&#123;&#125; @JsonIgnoreProperties public long meetingNumber; public String password; &#125; 修改系列化字段名称服务器给json字段有可能跟Entity类字段不一致，如何修改呢； Gson，可以为同一个字段映射两个json字段，如下文中name字段，json中如果只有fullName,name值为fullname字段的值，只有username则name值为username字段值，两者都有的话是对应alternate配置的字段值 1234567 public class SomeClassWithFields &#123; @SerializedName("name") public final String someField; @SerializedName(value = "fullName", alternate = "username") private String name; &#125; 123456789101112public clsss RequestMsg&#123;private String osType;@JsonProperty("os_type")public String getOs_Type()&#123;return this.osType;&#125;@JsonProperty(value="osType")public void setOsType(String osType)&#123;this.osType= osType;&#125;&#125; map的序列化对比key简单对象序列化Gson 1234567891011 HashMap&lt;String,String&gt; stringmap =new HashMap&lt;&gt;(); stringmap.put("2","sss"); stringmap.put("511","sss"); json = mapper.writeValueAsString(stringmap); System.out.println(json); GsonBuilder builder = new GsonBuilder(); builder.serializeNulls();// builder.enableComplexMapKeySerialization(); Gson gson = builder.create(); json = gson.toJson(stringmap); System.out.println(json); 输出结果 {“2”:”sss”,”511”:”sss”}{“2”:”sss”,”511”:”sss”} Key为复杂对象的系列化 12345678910111213141516171819202122232425 public static class Point &#123; public int x; public int y; public Point()&#123;&#125; public Point(int x,int y)&#123; this.x = x; this.y = y; &#125; &#125;public void test()&#123; String json = null; final ObjectMapper mapper =new ObjectMapper(); HashMap&lt;Point,String&gt; map = new HashMap&lt;&gt;(); map.put(new Point(3,5),"sdw"); map.put(new Point(6,2),"fasow"); json = mapper.writeValueAsString(map); System.out.println(json); GsonBuilder builder = new GsonBuilder(); builder.serializeNulls(); Gson gson = builder.create(); json = gson.toJson(map); System.out.println(json);&#125; 输出结果为 {“com.ytjojo.practice.Jackson$Point@f6c48ac”:”sdw”,”com.ytjojo.practice.Jackson$Point@13deb50e”:”fasow”}{“com.ytjojo.practice.Jackson$Point@f6c48ac”:”sdw”,”com.ytjojo.practice.Jackson$Point@13deb50e”:”fasow”} 可以发现直接调用的key.toString()方法，Point并没有序列化为json，最外层为{,如果GsonBuilde加上enableComplexMapKeySerialization()结果就不一样了，Gson序列化结果 [[{“x”:3,”y”:5},”sdw”],[{“x”:6,”y”:2},”fasow”]] 可以发现整个map就是jsonArray，key和value组成的JsonArray是Array的子项目。很遗憾，目前为止未发现Jackson原生支持这种序列化方式，如何让Jackson支持这种呢？看代码 1234567891011121314151617181920final ObjectMapper mapper =new ObjectMapper(); SimpleModule simpleModule = new SimpleModule(); simpleModule.addSerializer(Map.class, new JsonSerializer&lt;Map&gt;() &#123; @Override public void serialize(Map value, JsonGenerator gen, SerializerProvider serializers) throws IOException, JsonProcessingException &#123; if(value != null)&#123; gen.writeStartArray(); for(Object item: value.entrySet())&#123; Map.Entry entry = (Map.Entry) item; gen.writeStartArray(); gen.writeObject(entry.getKey()); gen.writeObject(entry.getValue()); gen.writeEndArray(); &#125; gen.writeEndArray(); &#125; &#125; &#125;); mapper.registerModule(simpleModule); 最后输出结果和Gson一样了 map反序列化简单key反序列化Gson和jackson都是统一的，不用做比较 复杂key反序列化比较Gson 123456789String json = "[[&#123;\"x\":10,\"y\":10&#125;,\"Ten\"],[&#123;\"x\":20,\"y\":20&#125;,\"Twenty\"]]"; GsonBuilder builder = new GsonBuilder(); builder.serializeNulls(); Gson gson = builder.create(); HashMap&lt;Point,String&gt; map = null; map = gson.fromJson(json,new TypeToken&lt;HashMap&lt;Point,String&gt;&gt;()&#123;&#125;.getType()); System.out.println(map.entrySet().iterator().next().getKey().x); 此时Gson能正常解析；看看Jackson12345String json = "[[&#123;\"x\":10,\"y\":10&#125;,\"Ten\"],[&#123;\"x\":20,\"y\":20&#125;,\"Twenty\"]]";final ObjectMapper mapper =new ObjectMapper();HashMap&lt;Point,String&gt; map = null;map = mapper.readValue(json, new TypeReference&lt;HashMap&lt;Point,String&gt;&gt;() &#123;&#125;); System.out.println(map.keySet().size()+"" +map); 发现报错了 com.fasterxml.jackson.databind.JsonMappingException: Can not find a (Map) Key deserializer for type [simple type, class com.ytjojo.practice.Jackson$Point]at [Source: [[{“x”:10,”y”:10},”Ten”],[{“x”:20,”y”:20},”Twenty”]]; line: 1, column: 1]at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:244)at com.fasterxml.jackson.databind.deser.DeserializerCache._handleUnknownKeyDeserializer(DeserializerCache.java:587)at com.fasterxml.jackson.databind.deser.DeserializerCache.findKeyDeserializer(DeserializerCache.java:168)at com.fasterxml.jackson.databind.DeserializationContext.findKeyDeserializer(DeserializationContext.java:500)at com.fasterxml.jackson.databind.deser.std.MapDeserializer.createContextual(MapDeserializer.java:231)at com.fasterxml.jackson.databind.DeserializationContext.handleSecondaryContextualization(DeserializationContext.java:685)at com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:482)at com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3889)at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3784)at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2798) Jackson默认是不支持解析key复杂对象的。用ObjectMapper注册SimpleModule，SimpleModule加上自定义HashMap的JsonDeserializer 123456789String json = "[[&#123;\"x\":10,\"y\":10&#125;,\"Ten\"],[&#123;\"x\":20,\"y\":20&#125;,\"Twenty\"]]";final ObjectMapper mapper =new ObjectMapper();SimpleModule simpleModule = new SimpleModule();//注册一定是HashMap.class不能是Map.class不然走不到自定义的JsonDeserializer里面去simpleModule.addDeserializer(HashMap.class,new Key());mapper.registerModule(simpleModule); HashMap&lt;Point,String&gt; map = null; map = mapper.readValue(json, new TypeReference&lt;HashMap&lt;Point,String&gt;&gt;() &#123;&#125;);System.out.println(map.keySet().size()+"" +map); 最关键的就是Key这个类了继承自JsonDeserializer，源码在此： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Key extends JsonDeserializer&lt;HashMap&lt;Object, Object&gt;&gt; implements ContextualDeserializer &#123; JavaType mJavaType; JavaType mKeyJavaType;//key对应的JavaType JavaType mValueJavaType;//Value对应的JavaType JsonDeserializer&lt;Object&gt; _valueDeserializer; JsonDeserializer&lt;Object&gt; _keyDeserializer; @Override public HashMap&lt;Object, Object&gt; deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException &#123; HashMap hashMap = new HashMap(); if (p.getCurrentToken() == JsonToken.START_ARRAY) &#123; JsonToken next = p.nextToken(); while (p.nextToken() != JsonToken.END_ARRAY) if (next != null &amp;&amp; next == JsonToken.START_ARRAY) &#123; p.nextToken(); //反序列化key Object key = _keyDeserializer.deserialize(p, ctxt); p.nextToken(); //反序列化Value Object value = _valueDeserializer.deserialize(p, ctxt); hashMap.put(key, value); p.nextToken(); &#125; &#125; return hashMap; &#125; @Override public JsonDeserializer&lt;?&gt; createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException &#123; if (property != null) &#123; //如果当前Hashmap是类的属性property不为null，如果根就是hashmap，就会为null； mJavaType = property.getType(); // -&gt; beanProperty is null when the StringConvertible type is a root value &#125; else &#123; mJavaType = ctxt.getContextualType(); &#125; mKeyJavaType = mJavaType.getKeyType(); mValueJavaType = mJavaType.getContentType(); _keyDeserializer = ctxt.findContextualValueDeserializer(mKeyJavaType, property); _valueDeserializer = ctxt.findContextualValueDeserializer(mValueJavaType, property); return this; &#125;&#125; 总体流程就是获得Key和value的javaType，然后找到对应的序列化类，根据JsonParser的token值在适当的位置进行反序列话，然后加如HashMap 服务器返回json字段是转义后的，带有反斜杠比如下面这种json {“code”:200,”body”: “{\”meetingNumber\”:\”2\”,\”password\”:\”sdwsdwsdw\”}”}这种json ，body字段被转义了，带有反斜杠\，估计后台的同学是直接用String类型赋值给body的，然后过json转换就会有转义字符。body对应的实体类12345678910 public static class Response &#123; public int code; public Body body; &#125; public static class Body &#123;public Body()&#123;&#125; public long meetingNumber; public String password; &#125; 不管用gson还是Jackson解析都是失败的。gson报的错为12345com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING at line 1 column 22 path $.bodyat com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:224)at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:129)at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:220) Jackson报的错误为12345678910111213141516com.fasterxml.jackson.databind.JsonMappingException: Can not instantiate value of type [simple type, class com.ytjojo.practice.JsonTest$Body] from String value ('&#123;"meetingNumber":"2","password":"sdwsdwsdw"&#125;'); no single-String constructor/factory method at [Source: &#123;"code":200,"body": "&#123;\"meetingNumber\":\"2\",\"password\":\"sdwsdwsdw\"&#125;"&#125;; line: 1, column: 21] (through reference chain: com.ytjojo.practice.Response["body"]) at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:216) at com.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:894) at com.fasterxml.jackson.databind.deser.ValueInstantiator._createFromStringFallbacks(ValueInstantiator.java:316) at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createFromString(StdValueInstantiator.java:288) at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromString(BeanDeserializerBase.java:1200) at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:144) at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:135) at com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:490) at com.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101) at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:260) at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:125) at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3788) at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2779) 怎么解决这个问题呢，显看Jackson的处理方式 Jackson有两种处理方式方法1 用在字段上注解@JsonDeserialize 1234567891011 public static class Response &#123; public int code; @JsonDeserialize(using = StringToObjectDeserializer.class) public Body body; &#125; public static class Body &#123;public Body()&#123;&#125; public long meetingNumber; public String password; &#125; StringToObjectDeserializer的源码1234567891011121314151617181920212223242526272829303132333435363738 private static class StringToObjectDeserializer extends JsonDeserializer&lt;Object&gt; implements ContextualDeserializer &#123; private JavaType valueType; @Override public JsonDeserializer&lt;?&gt; createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException &#123;// JavaType wrapperType = property.getType();// JavaType valueType = wrapperType.containedType(0); // if (property != null) valueType = property.getType(); // -&gt; beanProperty is null when the StringConvertible type is a root value else &#123; valueType = ctxt.getContextualType(); &#125; return this; &#125; @Override public Object deserialize(JsonParser parser, DeserializationContext ctxt) throws IOException &#123; String json =parser.getValueAsString(); //ObjectMapper一般需要配置成单例，这里直接新建，不做配置了 return new ObjectMapper().readValue(json,valueType); &#125; @Override public Object getNullValue() &#123; //可以直接返回null也可生成一个空对象 Class&lt;?&gt; clazz=valueType.getRawClass(); try &#123; return clazz.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return super.getNullValue(); &#125; &#125; 方法2用于全局配置，一劳永逸123 SimpleModule simleModule = new SimpleModule().setDeserializerModifier(new StringToObjectDeserializerModifier()); ObjectMapper objectMapper = new ObjectMapper().registerModule(simleModule);//配置 和解析代码不贴了。 StringToObjectDeserializerModifier源码很简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static class StringToObjectDeserializerModifier extends BeanDeserializerModifier &#123; public JsonDeserializer&lt;?&gt; modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc, JsonDeserializer&lt;?&gt; deserializer) &#123; if (deserializer.getClass() == BeanDeserializer.class) &#123; JavaType valueType = beanDesc.getType(); return new StringToBeanDeserializer((BeanDeserializerBase) deserializer); &#125; return deserializer; &#125;&#125; public static class StringToBeanDeserializer extends BeanDeserializer &#123; /** * Copy-constructor that can be used by sub-classes to allow * copy-on-write style copying of settings of an existing instance. */ public StringToBeanDeserializer(BeanDeserializerBase src) &#123; super(src, true); &#125; @Override public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException &#123; // First things first: id Object Id is used, most likely that's it if (_objectIdReader != null) &#123; return deserializeFromObjectId(p, ctxt); &#125; /* Bit complicated if we have delegating creator; may need to use it, * or might not... */ if (_delegateDeserializer != null) &#123; if (!_valueInstantiator.canCreateFromString()) &#123; Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) &#123; injectValues(ctxt, bean); &#125; return bean; &#125; &#125; String json = p.getValueAsString(); JavaType javatype = getValueType(); return new ObjectMapper().readValue(json, javatype); &#125; &#125; Gson中的处理gson中用到大杀器 @JsonAdapter。@JsonAdapter作用于字段可以自定义序列化方式，也可以自定反序列化。其中class是继承com.google.gson.JsonDeserializer自定义反序列化;或者继承自JsonSerializer自定义系列化本例的源码如下 1234567891011 public static class Response &#123; public int code; @JsonAdapter(GsonStringToObjectDeserializer.class) public Body body; &#125;public static class Body &#123; public Body()&#123;&#125; public long meetingNumber; public String password;&#125; GsonStringToObjectDeserializer的源码如下12345678910public class GsonStringToObjectDeserializer implements JsonDeserializer&lt;Object&gt; &#123; @Override public Object deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123; String jsonValue = json.getAsString(); return new Gson().fromJson(jsonValue,typeOfT); &#125;&#125; 这样我们的Jackson 和Gson都支持带有转义字段json解析成对应java实体对象了。 打造万能的Date解析方案服务器返回的日期格式有时候不太规范，目前服务器返回的有一下四种 1234public final static String yyyyMMdd = "yyyy-MM-dd";public final static String YYYMMDDHHMM = "yyyy-MM-dd HH:mm";public final static String YYMMDDHHMMSS = "yyyy-MM-dd HH:mm:ss";public final static String ENGLISH_MMMddYYYY= "MMM dd, yyyy";//Apr 25, 2016 Jackson中这种差异处理方式是Date字段上加上@JsonFormat注解 1234 @JsonFormat(timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm"private Date startTime; @JsonFormat(timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm:ss"private Date endTime; Gson处理方式还是用大杀器@JsonAdapter1234567891011121314 public static class Bean&#123; @JsonAdapter(GsonDateDeserializer.class) private Date startTime; @JsonAdapter(GsonDateDeserializer.class) private Date endTime; &#125; public class GsonDateDeserializer implements JsonDeserializer&lt;Date&gt; &#123; @Override public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123; return DateTimeHelper.getDateFromString(json.getAsString()); &#125;&#125; 但是上面Jackson和gson各自处理方式还是不太方便，类的字段加上注解才管用，如过全局生效，只需要配置Gson 或者ObjectMapper就完美了现在开撸，先上Gson代码配置 123456GsonBuilder builder = new GsonBuilder(); builder.enableComplexMapKeySerialization() .serializeNulls(); builder.registerTypeAdapterFactory(DateTypeAdapter.FACTORY); Gson gson =builder.create(); DateTypeAdapter源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public final class DateTypeAdapter extends TypeAdapter&lt;Date&gt; &#123; public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() &#123; @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal @Override public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; typeToken) &#123; return typeToken.getRawType() == Date.class ? (TypeAdapter&lt;T&gt;) new DateTypeAdapter() : null; &#125; &#125;; private final DateFormat enUsFormat = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US); private final DateFormat localFormat = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT); private final static SimpleDateFormat FORMAT_YYYMMDDHHMM =new SimpleDateFormat("yyyy-MM-dd HH:mm"); private final static SimpleDateFormat FORMAT_GMT =new SimpleDateFormat("EEE MMM ddHH:mm:ss 'GMT' yyyy",Locale.US); private final static SimpleDateFormat FORMAT_UTC =new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'"); @SuppressWarnings("unchecked") @Override public Date read(JsonReader in) throws IOException &#123; if (in.peek() == JsonToken.NULL) &#123; in.nextNull(); return null; &#125; return deserializeToDate(in.nextString()); &#125; private synchronized Date deserializeToDate(String json) &#123; try &#123; return localFormat.parse(json); &#125; catch (ParseException ignored) &#123; &#125; if(json.length() ==16)&#123; try &#123; return FORMAT_YYYMMDDHHMM.parse(json); &#125; catch (ParseException e) &#123; throw new JsonSyntaxException(json, e); &#125; &#125; if(json.contains("GMT"))&#123; try &#123; return FORMAT_GMT.parse(json); &#125; catch (ParseException e) &#123; &#125; try&#123; Date date =new Date(); date.setTime(GMTDateUtils.parseDate(json,0,json.length())); return date; &#125;catch (IllegalArgumentException e)&#123; &#125; &#125; try &#123; return FORMAT_UTC.parse(json); &#125; catch (ParseException e) &#123; &#125; try &#123; return enUsFormat.parse(json); &#125; catch (ParseException ignored) &#123; &#125; ParseException parseException; try &#123; return ISO8601Utils.parse(json, new ParsePosition(0)); &#125; catch (ParseException e) &#123; parseException = e; &#125; Date result= UTCDateUtils.parseDate(json); if(result == null)&#123; throw new JsonSyntaxException(json, parseException); &#125; return result; &#125; @Override public synchronized void write(JsonWriter out, Date value) throws IOException &#123; if (value == null) &#123; out.nullValue(); return; &#125; String dateFormatAsString = FORMAT_YYYMMDDHHMM.format(value); out.value(dateFormatAsString); &#125;&#125; Gson 处理方式就是自定义Date 的TypeAdapter，然后在GsonBuilder中注册该TypeAdapter.其中utc格式处理和Gmt解析源码我就补贴了 Jackson全局配置源码如下 123 ObjectMapper objectMapper = new ObjectMapper();//忽略其他各种配置 SuperDateDeserializer.regist(objectMapper); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * SuperDateDeserializer */public class SuperDateDeserializer extends DateDeserializers.DateDeserializer &#123; public static void regist(ObjectMapper mapper) &#123; mapper.registerModule(new SimpleModule().addDeserializer(Date.class, new SuperDateDeserializer())); &#125; public SuperDateDeserializer() &#123; super(); &#125; public SuperDateDeserializer(SuperDateDeserializer base, DateFormat df, String formatString) &#123; super(base, df, formatString); &#125; @Override protected SuperDateDeserializer withDateFormat(DateFormat df, String formatString) &#123; return new SuperDateDeserializer(this, df, formatString); &#125; @Override protected Date _parseDate(JsonParser p, DeserializationContext ctxt) throws IOException &#123; if (_customFormat != null) &#123; JsonToken t = p.getCurrentToken(); if (t == JsonToken.VALUE_STRING) &#123; String str = p.getText().trim(); if (str.length() == 0) &#123; return (Date) getEmptyValue(ctxt); &#125; SimpleDateFormat simpleDateFormat = (SimpleDateFormat) _customFormat; String patten = simpleDateFormat.toPattern(); if (patten.length() != str.length()) &#123; return getDateFromString(str); &#125; synchronized (_customFormat) &#123; try &#123; return _customFormat.parse(str); &#125; catch (ParseException e) &#123; throw new IllegalArgumentException("Failed to parse Date value '" + str + "' (format: \"" + _formatString + "\"): " + e.getMessage()); &#125; &#125; &#125; // Issue#381 if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) &#123; p.nextToken(); final Date parsed = _parseDate(p, ctxt); t = p.nextToken(); if (t != JsonToken.END_ARRAY) &#123; throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, "Attempted to unwrap single value array for single 'java.util.Date' " + "value but there was more than a single value in the array"); &#125; return parsed; &#125; &#125; JsonToken t = p.getCurrentToken(); if (t == JsonToken.VALUE_STRING) &#123; String str = p.getText().trim(); return getDateFromString(str); &#125; return super._parseDate(p, ctxt); &#125; /** * 返回Date类型 * @param dateStr 支持三种格式的输入字符串 * @return Date值 */ public static Date getDateFromString(String dateStr) &#123; if (TextUtils.isEmpty(dateStr)) &#123; return null; &#125; final String trimStr = dateStr.trim(); SimpleDateFormat df = null; switch (trimStr.length()) &#123; case 19: df = new SimpleDateFormat(YYMMDDHHMMSS); try &#123; return df.parse(trimStr); &#125; catch (ParseException e) &#123; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; case 16: df = new SimpleDateFormat(YYYMMDDHHMM); try &#123; return df.parse(trimStr); &#125; catch (ParseException e) &#123; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; case 10: df = new SimpleDateFormat(YYYYMMDD); try &#123; return df.parse(trimStr); &#125; catch (ParseException e) &#123; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; case 12: df = new SimpleDateFormat(ENGLISH_MMMDDYYYY, Locale.ENGLISH); try &#123; return df.parse(trimStr); &#125; catch (ParseException e) &#123; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; default: //如果想添加Uct和gmt格式处理就在这里添加 return null; &#125; &#125; public static final String YYYYMMDD = "yyyy-MM-dd"; public static final String YYYMMDDHHMM = "yyyy-MM-dd HH:mm"; public static final String YYMMDDHHMMSS = "yyyy-MM-dd HH:mm:ss"; public static final String ENGLISH_MMMDDYYYY = "MMM dd, yyyy";//Apr 25, 2016&#125; Jackson处理方式还是ObjectMapper.registerModule,注册SimpleModule，在SimplModule中添加Date类型DateDeserializer这样再也不用担心服务器返回各种奇怪日期格式造成解析失败了 手动调用Api生成jsonGson中12345678910111213141516171819Gson gson = new Gson();StringWriter stringWriter = new StringWriter();JsonWriter jsonWriter = gson.newJsonWriter(stringWriter);jsonWriter.beginObject();jsonWriter.name("name") .value("张三") .name("emails") .beginArray() .value("ytjojo@163.com") .value("ytjojo@qq.com") .endArray() .name("age") .value(20) .endObject();jsonWriter.flush();jsonWriter.close();String json = stringWriter.toString();System.out.println(json); 输出结果{“name”:”张三”,”emails”:[“ytjojo@163.com“,”ytjojo@qq.com“],”age”:20} Jackson生成json方法如下12345678910111213141516171819StringWriter stringWriter = new StringWriter(); JsonGenerator generator = new ObjectMapper().getFactory().createGenerator(stringWriter); generator.writeStartObject(); generator.writeStringField("name", "张三"); generator.writeNumberField("age", 20); generator.writeFieldName("emails"); generator.writeStartArray(); generator.writeString("ytjojo@163.com"); generator.writeString("ytjojo@qq.com"); generator.writeEndArray(); generator.writeFieldName("bean"); generator.writeEndObject(); generator.flush(); generator.close(); String json = stringWriter.toString(); System.out.println(json); 输出结果{“name”:”张三”,”age”:20,”emails”:[“ytjojo@163.com“,”ytjojo@qq.com“]}generator中还有个writeObject(Object pojo)方法，直接将pojo类写入json中，Gson貌似没这个功能 手动解析Json，Gson中为JsonElement，Jackson为JsonNodeGson12345678910111213141516171819202122232425262728Gson gson = new Gson(); String json = "&#123;\"name\":\"张三\",\"age\":20,\"emails\":[\"ytjojo@163.com\",\"ytjojo@qq.com\"]&#125;"; JsonElement rootEl = gson.fromJson(json, JsonElement.class); if (rootEl.isJsonObject()) &#123; JsonObject jsonObject = rootEl.getAsJsonObject(); JsonElement nameEl = jsonObject.get("name"); if (nameEl.isJsonPrimitive()) &#123; String name = nameEl.getAsString(); System.out.println(name); &#125; JsonElement emailsEl = jsonObject.get("emails"); if(emailsEl.isJsonArray())&#123; JsonArray jsonArray = emailsEl.getAsJsonArray(); for(int i= 0 ;i&lt; jsonArray.size() ;i++)&#123; String email =jsonArray.get(i).getAsString(); System.out.println(email); &#125; &#125; JsonElement ageEl = jsonObject.get("age"); if(ageEl.isJsonPrimitive())&#123; JsonPrimitive agePmt= ageEl.getAsJsonPrimitive(); if(agePmt.isNumber())&#123; int age = agePmt.getAsInt(); System.out.println(age+""); &#125; &#125; &#125; 张三ytjojo@163.comytjojo@qq.com20Jackson手动解析JsonNode1234567891011121314151617181920212223242526String json = "&#123;\"name\":\"张三\",\"age\":20,\"emails\":[\"ytjojo@163.com\",\"ytjojo@qq.com\"]&#125;"; ObjectMapper objectMapper = new ObjectMapper(); JsonNode node = objectMapper.readTree(json); if(node.isObject())&#123; JsonNode nameNode = node.path("name");//path和get方法功能类似，具体可以看文档 if(nameNode.isTextual())&#123; String name = nameNode.asText(); System.out.println(name); &#125; JsonNode ageNode = node.path("age"); if(ageNode.isNumber())&#123; int age = ageNode.asInt(); System.out.println(age+""); &#125; JsonNode emailsNode = node.path("emails"); if(emailsNode.isArray())&#123; for (int i = 0; i &lt; emailsNode.size(); i++) &#123; JsonNode emailNode = emailsNode.get(i); if(emailNode.isTextual())&#123; String email = emailNode.asText(); System.out.println(email); &#125; &#125; &#125; &#125; 构建泛型类得Type JacksonJavaType，如何反序列化泛型类如ArrayList就需要生成Type或者JavaType，传给Gson和ObjectMapper进行反序列化。Gson和Jackson都有自己的Api来进程处理，代码入下：Gson 1234567891011121314 Type type = new TypeToken&lt;ArrayList&lt;String&gt;&gt;()&#123;&#125;.getType();Primitives.isWrapperType() //等同于以下下代码 type = $Gson$Types.newParameterizedTypeWithOwner(null,ArrayList.class,String.class); 还可以判断是不是基本数据类型和包装类 boolean isWrapperType = Primitives.isWrapperType(Integer.class);//true boolean isPrimitive = Primitives.isPrimitive(String.class);//false boolean isintPrimitive = Primitives.isPrimitive(int.class);//true boolean isIntegerPrimitive = Primitives.isPrimitive(Integer.class);//false//判断是不是泛型类行 if(type instanceof ParameterizedType)&#123; System.out.println("ParameterizedType");//Arraylist属于泛型类 &#125; Jackson生成泛型type123Type type = new TypeReference&lt;ArrayList&lt;String&gt;&gt;()&#123;&#125;.getType(); JavaType javaType = new ObjectMapper().getTypeFactory().constructParametricType(ArrayList.class,String.class); boolean isTypeOrSubTypeOf = javaType.isTypeOrSubTypeOf(List.class);//是不是List子类，true 有了Type和JavaType我们就可以解析出具体实体类。 完结关于Gson 和Jackson的使用目前就介绍到这里，如果在项目新get的使用技巧会继续补充。Thanks to read！]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>Gson</tag>
        <tag>Jackson</tag>
        <tag>json转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lint工作流程研究]]></title>
    <url>%2F2018%2F03%2F16%2Flint%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[文章会试图解答如下问题 lintOptions如何获取 系统定义Issues如何被加载进来的 用户自定lint.jar如何被找到的 Detector如何加载的 lint总体流程 创建AndroidProject 获得LintOptions配置信息 获得系统定义的IssueRegistry(为BuiltinIssueRegistry的子类) 获得所有lint.jar 获得所有定义的Issues，包括系统和用户定义的 获得检测范围Scope 获得Detectors，获取lint.xml配置信息 checkProject检查当前工程和所有依赖工程 runFileDetectors lint入口gradle 任务的入口入口类为com.android.build.gradle.tasks.Lint.groovy 获得projectlint()方法中,先创建AndroidProject对象首先判断是单个变体还是所有变体如果命令gradle app:lint则是所有变体如果命令是radle app:lintDebug则值检查debug变体 12345678910111213@TaskAction public void lint() throws IOException &#123; AndroidProject modelProject = createAndroidProject(getProject()); if (getVariantName() != null &amp;&amp; !getVariantName().isEmpty()) &#123; for (Variant variant : modelProject.getVariants()) &#123; if (variant.getName().equals(getVariantName())) &#123; lintSingleVariant(modelProject, variant); &#125; &#125; &#125; else &#123; lintAllVariants(modelProject); &#125; &#125; 如何获得变体呢，这就是createAndroidProject的作用了。进入该方法，方法内部又调用ToolingModelBuilder的buildAll（）方法buildAll调用buildAndroidProject（），在这里会根据buildType和productFlavors生成各种变体，获得各种配置信息，特别是LintOptions为后来lint检查做准备。这信息最终保存在DefaultAndroidProject中，DefaultAndroidProject最终赋值给lint()方法的临时变量modelProject中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 private Object buildAndroidProject(Project project) &#123; Integer modelLevelInt = AndroidGradleOptions.buildModelOnlyVersion(project); if (modelLevelInt != null) &#123; modelLevel = modelLevelInt; &#125; modelWithFullDependency = AndroidGradleOptions.buildModelWithFullDependencies(project); // Get the boot classpath. This will ensure the target is configured. List&lt;String&gt; bootClasspath = androidBuilder.getBootClasspathAsStrings(false); List&lt;File&gt; frameworkSource = Collections.emptyList(); // List of extra artifacts, with all test variants added. List&lt;ArtifactMetaData&gt; artifactMetaDataList = Lists.newArrayList( extraModelInfo.getExtraArtifacts()); for (VariantType variantType : VariantType.getTestingTypes()) &#123; artifactMetaDataList.add(new ArtifactMetaDataImpl( variantType.getArtifactName(), true /*isTest*/, variantType.getArtifactType())); &#125; //根据gradle文件中配置的lintOptions获得配置结果，保存在LintOptions这个类中 LintOptions lintOptions = com.android.build.gradle.internal.dsl.LintOptions.create( config.getLintOptions()); AaptOptions aaptOptions = AaptOptionsImpl.create(config.getAaptOptions()); List&lt;SyncIssue&gt; syncIssues = Lists.newArrayList(extraModelInfo.getSyncIssues().values()); List&lt;String&gt; flavorDimensionList = config.getFlavorDimensionList() != null ? config.getFlavorDimensionList() : Lists.newArrayList(); toolchains = createNativeToolchainModelMap(ndkHandler); ProductFlavorContainer defaultConfig = ProductFlavorContainerImpl .createProductFlavorContainer( variantManager.getDefaultConfig(), extraModelInfo.getExtraFlavorSourceProviders( variantManager.getDefaultConfig().getProductFlavor().getName())); Collection&lt;BuildTypeContainer&gt; buildTypes = Lists.newArrayList(); Collection&lt;ProductFlavorContainer&gt; productFlavors = Lists.newArrayList(); Collection&lt;Variant&gt; variants = Lists.newArrayList(); //获取配置的buildType for (BuildTypeData btData : variantManager.getBuildTypes().values()) &#123; buildTypes.add(BuildTypeContainerImpl.create( btData, extraModelInfo.getExtraBuildTypeSourceProviders(btData.getBuildType().getName()))); &#125; //获取配置的ProductFlavors for (ProductFlavorData pfData : variantManager.getProductFlavors().values()) &#123; productFlavors.add(ProductFlavorContainerImpl.createProductFlavorContainer( pfData, extraModelInfo.getExtraFlavorSourceProviders(pfData.getProductFlavor().getName()))); &#125;//生成所有组合后的变体，如ProductFlavors 为feature1 则变体为feature1Debug 和feature1Release for (BaseVariantData&lt;? extends BaseVariantOutputData&gt; variantData : variantManager.getVariantDataList()) &#123; if (!variantData.getType().isForTesting()) &#123; variants.add(createVariant(variantData)); &#125; &#125; return new DefaultAndroidProject( Version.ANDROID_GRADLE_PLUGIN_VERSION, project.getName(), defaultConfig, flavorDimensionList, buildTypes, productFlavors, variants, androidBuilder.getTarget() != null ? androidBuilder.getTarget().hashString() : &quot;&quot;, bootClasspath, frameworkSource, cloneSigningConfigs(config.getSigningConfigs()), aaptOptions, artifactMetaDataList, findUnresolvedDependencies(syncIssues), syncIssues, config.getCompileOptions(), lintOptions, project.getBuildDir(), config.getResourcePrefix(), ImmutableList.copyOf(toolchains.values()), config.getBuildToolsVersion(), projectType, Version.BUILDER_MODEL_API_VERSION, generation); &#125; 获得androidProject后进入runLint()这个方法，进入下一个环节 获取系统定义IssueRegistry，在此方法中主要功能是做配置和初始化核心类 在runlint方法中首先通过createIssueRegistry获得系统的IssueRegistry该类为LintGradleIssueRegistry 继承自BuiltinIssueRegistryBuiltinIssueRegistry的静态代码块添加所有系统定义好的Issues，总共293个并在getIssues()方法中返回Issues集合，这就是系统定义Issue来源再次回到runLint方法中 初始化LintGradleClient，并执行client.run()该方法主要是四个功能初始化IssueRegistry，syncOptions同步LintOptions初始化LintGradleClient执行client.run(registry)最关键的是client.run(registry)，最终调用lintDrver的analysis方法12345678910111213private Pair&lt;List&lt;Warning&gt;,LintBaseline&gt; runLint( IssueRegistry registry = createIssueRegistry(); LintCliFlags flags = new LintCliFlags(); LintGradleClient client = new LintGradleClient(registry, flags, getProject(), modelProject, sdkHome, variant, getBuildTools()); //... try &#123; warnings = client.run(registry); &#125; catch (IOException e) &#123; throw new GradleException("Invalid arguments.", e); &#125;&#125; client.run(registry)方法最终走到public int run(@NonNull IssueRegistry registry, @NonNull List&lt;File&gt; files)这个方法 初始化LintDriver123456789101112131415 public int run(@NonNull IssueRegistry registry, @NonNull List&lt;File&gt; files) throws IOException &#123; assert !flags.getReporters().isEmpty(); this.registry = registry; driver = new LintDriver(registry, this); driver.setAbbreviating(!flags.isShowEverything()); //调用driver启动分析 driver.analyze(createLintRequest(files)); ... return flags.isSetExitCode() ? (hasErrors ? ERRNO_ERRORS : ERRNO_SUCCESS) : ERRNO_SUCCESS; &#125; 在这个方法中可以看到初始化LintDriver,并调用driver.analyze(createLintRequest(files))其中还有个关键方法createLintRequest(files) 创建LintRequest类12345678910111213141516protected LintRequest createLintRequest(@NonNull List&lt;File&gt; files) &#123; LintRequest lintRequest = new LintRequest(this, files); if (Lint.MODEL_LIBRARIES) &#123; LintGradleProject.ProjectSearch search = new LintGradleProject.ProjectSearch(); Project project = search.getProject(this, gradleProject, variant.getName()); lintRequest.setProjects(Collections.singletonList(project)); setCustomRules(search.customViewRuleJars); &#125; else &#123; Pair&lt;LintGradleProject,List&lt;File&gt;&gt; result = LintGradleProject.create( this, modelProject, variant, gradleProject); lintRequest.setProjects(Collections.singletonList(result.getFirst())); setCustomRules(result.getSecond()); &#125; return lintRequest; &#125; 此方法有三个作用 org.gradle.api.Project转换为com.android.tools.lint.detector.api.Project,并赋值给lintRequest 搜集放在工程或者第三方依赖的lint.jar 将搜集的lint.jar集合复制给lintClient的customRules 生成LintRequest对象 如何搜集lint.jar 先检查当前Project的build目录如果/build/lint/lint.jar存在则将File保存在customViewRuleJars中 从依赖的项目获取lint.jar可以是工程，也可以是第三方库中aar中lint.jar第三方库lint.jar一般会放入build-cache中如C:\Users\Administrator.android\build-cache\0c1baf206b683783b1aeb51ee8d63025f569746d\output\jars\lint.jar依赖的工程的lint.jar地址E:\github\LintRulesForAndroid\module_news\build\intermediates\bundles\default\lint.jar 在createLintRequest方法中 创建LintGradleProject.ProjectSearch对象，调用其getProject方法在此方法把找到lint.jar放入customViewRuleJars这个数组中然后调用LintGradleClient的setCustomRules把lint.jar数组赋值给 给customRules，进入getProject()查看获得lint.jar的源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public Project getProject( @NonNull LintGradleClient client, @NonNull AndroidProject project, @NonNull Variant variant, @NonNull org.gradle.api.Project gradleProject) &#123; Project cached = appProjects.get(project); if (cached != null) &#123; return cached; &#125; mSeen.add(project); File dir = gradleProject.getProjectDir(); AppGradleProject lintProject = new AppGradleProject(client, dir, dir, project, variant); appProjects.put(project, lintProject); //build/lint/lint.jar判断是否存在，存在就保存到customViewRuleJars File appLintJar = new File(gradleProject.getBuildDir(), &quot;lint&quot; + separatorChar + &quot;lint.jar&quot;); if (appLintJar.exists()) &#123; customViewRuleJars.add(appLintJar); &#125; // DELIBERATELY calling getDependencies here (and Dependencies#getProjects() below) : // the new hierarchical model is not working yet. Dependencies dependencies = variant.getMainArtifact().getDependencies(); for (AndroidLibrary library : dependencies.getLibraries()) &#123; if (library.getProject() != null) &#123; // Handled below // ...except in that case we don&apos;t find custom rule jars (since those are // tied to the AndroidLibrary); include those here. File ruleJar = library.getLintJar(); // 第三方库lint.jar是否存在 //C:\Users\Administrator\.android\build-cache\0c1baf206b683783b1aeb51ee8d63025f569746d\output\jars\lint.jar //E:\github\LintRulesForAndroid\module_news\build\intermediates\bundles\default\lint.jar if (ruleJar.exists()) &#123; customViewRuleJars.add(ruleJar); &#125; continue; &#125; lintProject.addDirectLibrary(getLibrary(client, library, gradleProject, variant)); &#125; return lintProject; &#125; lintDriver.analyze()创建完LintRequet，此后开始进入LintDriver的analyze()方法，这才是真正lint启动的地方123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private void analyze() &#123; scope = request.getScope(); assert scope == null || !scope.contains(Scope.ALL_RESOURCE_FILES) || scope.contains(Scope.RESOURCE_FILE); Collection&lt;Project&gt; projects; try &#123; //获得需要检测的Project projects = request.getProjects(); if (projects == null) &#123; projects = computeProjects(request.getFiles()); &#125; &#125; catch (CircularDependencyException e) &#123; &#125; if (projects.isEmpty()) &#123; client.log(null, &quot;No projects found for %1$s&quot;, request.getFiles().toString()); return; &#125; if (canceled) &#123; return; &#125; //找到所有的lint.jar并获得系统和用户自定义ISsues registerCustomDetectors(projects); if (scope == null) &#123; scope = Scope.infer(projects); &#125; for (Project project : projects) &#123; phase = 1; Project main = request.getMainProject(project); // The set of available detectors varies between projects //根据ISsues获得所有Detectors computeDetectors(project); if (applicableDetectors.isEmpty()) &#123; // No detectors enabled in this project: skip it continue; &#125; checkProject(project, main); if (canceled) &#123; break; &#125; runExtraPhases(project, main); &#125; &#125; 然后从LintRequest对象获取分析的project，如果为空通过computeProjects这个方法来找到需要扫描的Projet什么时候为空呢？ 如果直接输入命令 gradle lint 此时获得的projects为空，如果命令是gradle app:lint 则Projects为数组长度为1，仅包含app这个Project 原理就是根据扫描File列表调用 client.getProject(projectDir, rootDir)来获得Project对象如果发现循环依赖会报CircularDependencyException，例如 A 依赖B B依赖C,C又依赖A如果发现projects列表为空或者被用户取消则终止分析 获得系统和用户定义Issues下一步是registerCustomDetectors，通过lint.jar获得用户自定义Issue。这也是为什么lint.jar要放在build\intermediates\lint目录下或者用户目录下.android/lint目录会生效 这段代码是 1234567891011121314151617181920212223242526272829303132333435363738394041private void registerCustomDetectors(Collection&lt;Project&gt; projects) &#123; // Look at the various projects, and if any of them provide a custom // lint jar, "add" them (this will replace the issue registry with // a CompositeIssueRegistry containing the original issue registry // plus JarFileIssueRegistry instances for each lint jar Set&lt;File&gt; jarFiles = Sets.newHashSet(); for (Project project : projects) &#123; jarFiles.addAll(client.findRuleJars(project)); for (Project library : project.getAllLibraries()) &#123; jarFiles.addAll(client.findRuleJars(library)); &#125; &#125; //从用户目录.android/lint目录获取lint.jar //我电脑上路径是C:/Users/Administrator/.android/lint/lint.jar jarFiles.addAll(client.findGlobalRuleJars()); if (!jarFiles.isEmpty()) &#123; List&lt;IssueRegistry&gt; registries = Lists.newArrayListWithExpectedSize(jarFiles.size()); registries.add(registry); for (File jarFile : jarFiles) &#123; try &#123; //从lint.jar获取JarFileIssueRegistry JarFileIssueRegistry registry = JarFileIssueRegistry.get(client, jarFile); if (registry.hasLegacyDetectors()) &#123; runCompatChecks = true; &#125; if (myCustomIssues == null) &#123; myCustomIssues = Sets.newHashSet(); &#125; myCustomIssues.addAll(registry.getIssues()); registries.add(registry); &#125; catch (Throwable e) &#123; client.log(e, "Could not load custom rule jar file %1$s", jarFile); &#125; &#125; if (registries.size() &gt; 1) &#123; // the first item is registry itself registry = new CompositeIssueRegistry(registries); &#125; &#125; &#125; demo中为jar地址E:\github\LintRulesForAndroid\module_news\build\intermediates\bundles\default\lint.jar 获得全局lint.jar源码解析client.findGlobalRuleJars()这个方法有两种方式获取 全局lint.jar路径，一种是从路径C:/Users/Administrator/.android/lint/lint.jar获取另外一种从系统环境变量ANDROID_LINT_JARS中获取。123456789101112131415161718192021222324252627282930313233343536373839404142434445public List&lt;File&gt; findGlobalRuleJars() &#123; // Look for additional detectors registered by the user, via // (1) an environment variable (useful for build servers etc), and // (2) via jar files in the .android/lint directory List&lt;File&gt; files = null;//获得androihome下的lintjar//我电脑上为C:/Users/Administrator/.android/lint/lint.jar try &#123; String androidHome = AndroidLocation.getFolder(); File lint = new File(androidHome + File.separator + "lint"); if (lint.exists()) &#123; File[] list = lint.listFiles(); if (list != null) &#123; for (File jarFile : list) &#123; if (endsWith(jarFile.getName(), DOT_JAR)) &#123; if (files == null) &#123; files = new ArrayList&lt;&gt;(); &#125; files.add(jarFile); &#125; &#125; &#125; &#125; &#125; catch (AndroidLocation.AndroidLocationException e) &#123; // Ignore -- no android dir, so no rules to load. &#125;//从环境变量中获取lint.jar的路径 String lintClassPath = System.getenv("ANDROID_LINT_JARS"); if (lintClassPath != null &amp;&amp; !lintClassPath.isEmpty()) &#123; String[] paths = lintClassPath.split(File.pathSeparator); for (String path : paths) &#123; File jarFile = new File(path); if (jarFile.exists()) &#123; if (files == null) &#123; files = new ArrayList&lt;&gt;(); &#125; else if (files.contains(jarFile)) &#123; continue; &#125; files.add(jarFile); &#125; &#125; &#125; return files != null ? files : Collections.emptyList(); &#125; 根据所有的lint.jar获得JarFileIssueRegistry对象该对象保存所有的IssueRegistry注册的所有Issues 获取流程大致，是通过Mainfest找到属性值Lint-Registry-v2的变量如果为空，则继续根据Lint-Registry这个key继续查找，找到注册的value之后反射生成IssueRegistry对象，然后将所有的ISSues保存在JarFileIssueRegistry的issues这个集合里，最终将系统定义和用户定义ISsue统一放在CompositeIssueRegistry中。至此获得所有Issue的流程已完成。 所有的ISsue已经保存在CompositeIssueRegistry，下一步根据Issue获得定义所有Detectors 获取所有Detecotr我们自定义检查都要继承Detector这个类，获取的地方是在analysis()中调用的computeDetectors() 12345678910private void computeDetectors(@NonNull Project project) &#123; //.... Configuration configuration = project.getConfiguration(this); scopeDetectors = new EnumMap&lt;&gt;(Scope.class); applicableDetectors = registry.createDetectors(client, configuration, scope, scopeDetectors); //....&#125; 最终调用IssueRegistry的createDetectors(()方法 checkProject检查当前项目和所有依赖项目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 private void checkProject(@NonNull Project project, @NonNull Project main) &#123; //..... for (Detector check : applicableDetectors) &#123;//回调Detector的beforeCheckProject方法 check.beforeCheckProject(projectContext); if (canceled) &#123; return; &#125; &#125; //..... //检查当前项目的java xml class gradle property等等 runFileDetectors(project, main); if (!Scope.checkSingleFile(scope)) &#123; List&lt;Project&gt; libraries = project.getAllLibraries(); for (Project library : libraries) &#123; Context libraryContext = new Context(this, library, project, projectDir); currentProject = library; for (Detector check : applicableDetectors) &#123;//回调Detector的beforeCheckLibraryProject方法 check.beforeCheckLibraryProject(libraryContext); if (canceled) &#123; return; &#125; &#125; //..... runFileDetectors(library, main); //..... for (Detector check : applicableDetectors) &#123; //回调Detector的afterCheckLibraryProject方法 check.afterCheckLibraryProject(libraryContext); if (canceled) &#123; return; &#125; &#125; &#125; &#125; currentProject = project; for (Detector check : applicableDetectors) &#123; //回调Detector的afterCheckProject方法 check.afterCheckProject(projectContext); if (canceled) &#123; return; &#125; &#125; &#125; 其中一个关键方法,按找一下顺序检查ManifestFiles-&gt;xml-&gt;java-&gt;class-&gt;gradle-&gt;其他-&gt;PROGUARD_FILE-&gt;-&gt;property file 一个关键方法getSubset，增量检测只检测部分文件或者文件夹的时候会有用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143private void runFileDetectors(@NonNull Project project, @Nullable Project main) &#123; // Look up manifest information (but not for library projects) if (project.isAndroidProject()) &#123; for (File manifestFile : project.getManifestFiles()) &#123; XmlParser parser = client.getXmlParser(); if (parser != null) &#123; XmlContext context = new XmlContext(this, project, main, manifestFile, null, parser); context.document = parser.parseXml(context); if (context.document != null) &#123; try &#123; project.readManifest(context.document); if ((!project.isLibrary() || (main != null &amp;&amp; main.isMergingManifests())) &amp;&amp; scope.contains(Scope.MANIFEST)) &#123; List&lt;Detector&gt; detectors = scopeDetectors.get(Scope.MANIFEST); if (detectors != null) &#123; ResourceVisitor v = new ResourceVisitor(parser, detectors, null); fireEvent(EventType.SCANNING_FILE, context); //检查mainfest.xml v.visitFile(context, manifestFile); &#125; &#125; &#125; finally &#123; if (context.document != null) &#123; // else: freed by XmlVisitor above parser.dispose(context, context.document); &#125; &#125; &#125; &#125; &#125; // Process both Scope.RESOURCE_FILE and Scope.ALL_RESOURCE_FILES detectors together // in a single pass through the resource directories. if (scope.contains(Scope.ALL_RESOURCE_FILES) || scope.contains(Scope.RESOURCE_FILE) || scope.contains(Scope.RESOURCE_FOLDER) || scope.contains(Scope.BINARY_RESOURCE_FILE)) &#123; List&lt;Detector&gt; dirChecks = scopeDetectors.get(Scope.RESOURCE_FOLDER); List&lt;Detector&gt; binaryChecks = scopeDetectors.get(Scope.BINARY_RESOURCE_FILE); List&lt;Detector&gt; checks = union(scopeDetectors.get(Scope.RESOURCE_FILE), scopeDetectors.get(Scope.ALL_RESOURCE_FILES)); boolean haveXmlChecks = checks != null &amp;&amp; !checks.isEmpty(); List&lt;ResourceXmlDetector&gt; xmlDetectors; if (haveXmlChecks) &#123; xmlDetectors = new ArrayList&lt;&gt;(checks.size()); for (Detector detector : checks) &#123; if (detector instanceof ResourceXmlDetector) &#123; xmlDetectors.add((ResourceXmlDetector) detector); &#125; &#125; haveXmlChecks = !xmlDetectors.isEmpty(); &#125; else &#123; xmlDetectors = Collections.emptyList(); &#125; if (haveXmlChecks || dirChecks != null &amp;&amp; !dirChecks.isEmpty() || binaryChecks != null &amp;&amp; !binaryChecks.isEmpty()) &#123; List&lt;File&gt; files = project.getSubset(); if (files != null) &#123; checkIndividualResources(project, main, xmlDetectors, dirChecks, binaryChecks, files); &#125; else &#123; List&lt;File&gt; resourceFolders = project.getResourceFolders(); if (!resourceFolders.isEmpty()) &#123; for (File res : resourceFolders) &#123; //检查文件夹、xml、二进制文件如png jpg webp checkResFolder(project, main, res, xmlDetectors, dirChecks, binaryChecks); &#125; &#125; &#125; &#125; &#125; if (canceled) &#123; return; &#125; &#125; if (scope.contains(Scope.JAVA_FILE) || scope.contains(Scope.ALL_JAVA_FILES)) &#123; List&lt;Detector&gt; checks = union(scopeDetectors.get(Scope.JAVA_FILE), scopeDetectors.get(Scope.ALL_JAVA_FILES)); if (checks != null &amp;&amp; !checks.isEmpty()) &#123; List&lt;File&gt; files = project.getSubset(); if (files != null) &#123; checkIndividualJavaFiles(project, main, checks, files); &#125; else &#123; List&lt;File&gt; sourceFolders = project.getJavaSourceFolders(); List&lt;File&gt; testFolders = scope.contains(Scope.TEST_SOURCES) ? project.getTestSourceFolders() : Collections.emptyList(); checkJava(project, main, sourceFolders, testFolders, checks); &#125; &#125; &#125; if (canceled) &#123; return; &#125; if (scope.contains(Scope.CLASS_FILE) || scope.contains(Scope.ALL_CLASS_FILES) || scope.contains(Scope.JAVA_LIBRARIES)) &#123; checkClasses(project, main); &#125; if (canceled) &#123; return; &#125; if (scope.contains(Scope.GRADLE_FILE)) &#123; checkBuildScripts(project, main); &#125; if (canceled) &#123; return; &#125; if (scope.contains(Scope.OTHER)) &#123; List&lt;Detector&gt; checks = scopeDetectors.get(Scope.OTHER); if (checks != null) &#123; OtherFileVisitor visitor = new OtherFileVisitor(checks); visitor.scan(this, project, main); &#125; &#125; if (canceled) &#123; return; &#125; if (project == main &amp;&amp; scope.contains(Scope.PROGUARD_FILE) &amp;&amp; project.isAndroidProject()) &#123; checkProGuard(project, main); &#125; if (project == main &amp;&amp; scope.contains(Scope.PROPERTY_FILE)) &#123; checkProperties(project, main); &#125; &#125; 打印和输出报告回到LintCliClient.run(@NonNull IssueRegistry registry, @NonNull List files)方法中在driver.analyze(createLintRequest(files))之后，有如下代码 123456789101112131415161718192021 Collections.sort(warnings);... boolean hasConsoleOutput = false; for (Reporter reporter : flags.getReporters()) &#123; reporter.write(stats, warnings); if (reporter instanceof TextReporter &amp;&amp; ((TextReporter)reporter).isWriteToConsole()) &#123; hasConsoleOutput = true; &#125; &#125; if (!flags.isQuiet() &amp;&amp; !hasConsoleOutput) &#123; System.out.print(String.format(&quot;Lint found %1$s&quot;, LintUtils.describeCounts(errorCount, warningCount, true))); if (baselineErrorCount &gt; 0 || baselineWarningCount &gt; 0) &#123; System.out.print(String.format(&quot; (%1$s filtered by baseline %2$s)&quot;, LintUtils.describeCounts(stats.baselineErrorCount, stats.baselineWarningCount, true), flags.getBaselineFile().getName())); &#125; System.out.println(); &#125; driver将扫描的问题全部保存在warnings这个列表里,然后进行排序输出，输出方式有html，xml和控制台输出到此基本上整个流程已分析完成 如何debug Lint源码先找的Edit Configurations,打开点加号添加一个remote类型切换到这个类型在terminal 输入命令 参数要加上 -Dorg.gradle.daemon=false -Dorg.gradle.debug=true如gradle app:lintDebug -Dorg.gradle.daemon=false -Dorg.gradle.debug=true此时运行起来会一直等待，点击debug按钮在点击terminal窗口就跑起来了]]></content>
      <categories>
        <category>lint</category>
      </categories>
      <tags>
        <tag>lint</tag>
        <tag>源码分析，androidLint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一看要懂的http简介]]></title>
    <url>%2F2017%2F12%2F25%2F%E4%B8%80%E7%9C%8B%E8%A6%81%E6%87%82%E7%9A%84http%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[URL简介URL（Uniform Resource Locator）是统一资源定位符的简称，有时候也被俗称为网页地址（网址），如同是网络上的门牌，是因特网上标准的资源的地址 通用的格式：schema://host[:port#]/path/…/[?query=string][#anchor] 名称 功能 schema 访问服务器以获取资源时要使用哪种协议，比如，http，https 和 FTP 等 host HTTP 服务器的 IP 地址或域名 port# HTTP 服务器的默认端口是 80，这种情况下端口号可以省略，如果使用了别的端口，必须指明，例如www.cnblogs.com：8080 path 访问资源的路径 query=string 发给 http 服务器的数据 anchor 锚 https://github.com/guodongxiaren/README#%E5%9B%BE%E7%89%87 请求方法HTTP 的请求方法共有 8 个，HTTP 协议 1.0 版本中定义了GET、POST、HEAD 这 3 个方法，1.1 版本时又新增了PUT、DELETE、TRACE、CONNECT、OPTION 这 5 个方法。其中最常用的是 GET 和 POST。 请求报文HTTP 请求报文的一般格式如图所示： 响应报文 响应报文包含状态行、响应报头、空行和响应正文 4 个部分。空行表示响应头部和正文的分隔，相应正文则表示服务器返回的资源的内容，主要介绍一下状态行和 HTTP 协议中的消息报头（请求报头和响应报头都属于它的一个分类，所以放在一起介绍）。 状态行状态行依次包括 HTTP 版本、状态码以及该状态码对应的原因短语，示例如下： HTTP/1.1 200 OK HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 100~199 ： 信息，服务器收到请求，需要请求者继续执行操作 200~299： 成功，操作被成功接收并处理 300~399 ： 重定向，需要进一步的操作以完成请求 400~499 ： 客户端错误，请求包含语法错误或无法完成请求 500~599 ： 服务器错误，服务器在处理请求的过程中发生了错误 常见的HTTP状态码有： 200 - OK 请求成功 301 - Moved Permanently 资源（网页等）被永久转移到其它URL 302 - Moved Temporarily 请求临时重定向 304 - Not Modified 缓存有效可以继续使用 400 - Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 - Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 - Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原 因 404 - Not Found 请求的资源（网页等）不存在 409 - 对当前资源状态，请求不能完成 500 - Internal Server Error 内部服务器错误 503 - Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 504 - Gateway Timeout/网关超时 HTTP的消息报头消息报头可以分为通用报头、请求报头、响应报头和实体报头。以键值对的形式存在，每行一对，名字和值之间用 “：” 来进行分隔。 通用报头通用报头既能出现在请求报头也能出现在响应报头中。 Date ： 发送消息的日期和时间 Connection ： 允许发送指定连接的选项。例如指定连接是连续，或者指定 “close” 选项，通知服务器，在响应完成后，关闭连接 Cache-Control ： 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制） 请求报头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常见的请求报头有： Host ： 发送请求时，该报头域是必需的。Host 请求报头域主要用于指定被请求资源的 Internet 主机和端口号，它通常从 HTTP URL 中提取出来。 User-Agent ： 允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 Accept ： 用于指定客户端接受哪些类型的信息。例如Accept：image/gif，表明客户端希望接受 GIF 图象格式的资源；Accept：text/html，表明客户端希望接受 html 文本。 Accept-Charset ： 用于指定客户端接受的字符集。 Accept-Encoding ： 用于指定可接受的内容编码。 Accept-Language ： 用于指定一种自然语言。例如 Accept-Language:zh-cn 表示支持中文。 Authorization ： 请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为 401（未授权），可以发送一个包含 Authorization 请求报头域的请求，要求服务器对其进行验证。 响应报头响应报头用于服务器向客户端发送信息。常见的响应报头有： Location ： 用于重定向接受者到一个新的位置，常用在更换域名的时候。 Server ： 包含了服务器用来处理请求的软件信息，与User-Agent请求报头域是相对应的。 WWW-Authenticate ： 必须被包含在 401（未授权的）响应消息中，客户端收到 401 响应消息时候，并发送 Authorization 报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。 实体报头请求和响应消息都可以传送一个实体。实体报头定义了关于实体正文和请求所标识的资源的元信息。常见的实体报头有： Content-Encoding ： 被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码。 Content-Language ： 描述了资源所用的自然语言。 Content-Length ： 用于指明实体正文的长度，以字节方式存储的十进制数字来表示。 Content-Type ： 实体报头域用语指明发送给接收者的实体正文的媒体类型。 Last-Modified ： 用于指示资源的最后修改日期和时间。 持久连接 Http1.0版 默认每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议），通过请求头中添加Connection: keep-alive来持久连接、连接重用。 http1.1版本 默认情况下所有连接都被保持，可以通过请求头中添加Connection: close来关闭 一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接。 以下是一个响应报文的实例： HTTP/1.1 304 Not Modified Date: Thu, 12 Oct 2017 09:20:27 GMT Via: 1.1 varnish Cache-Control: max-age=600 Expires: Thu, 12 Oct 2017 09:02:02 GMT Age: 0 Connection: keep-alive X-Served-By: cache-hkg17934-HKG X-Cache: MISSX-Cache-Hits: 0 X-Timer: S1507800028.883579,VS0,VE164 Vary: Accept-Encoding X-Fastly-Request-ID: 17fc09b064ce9669f38931c159ec01384cc3f8de 这是app log 输出请求 返回 常用的Http请求方法get请求GET用于信息获取，而且应该是安全的 和 幂等的。 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 幂等的意味着对同一URL的多个请求应该返回同样的结果。 post请求HTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们： application/x-www-form-urlencoded 这是最常见的 POST 数据提交方式。浏览器的原生 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。上个小节当中的例子便是使用了这种提交方式。可以看到 body 当中的内容和 GET 请求是完全相同的。 multipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 表单的 enctype 等于 multipart/form-data。直接来看一个请求示例： 12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。关于 multipart/form-data 的详细定义，请前往 RFC1867 查看（或者相对友好一点的 MDN 文档）。 这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 表单也只支持这两种方式（通过 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。 随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，例如 application/json，text/xml，乃至 application/x-protobuf 这种二进制格式，只要服务器可以根据 Content-Type 和 Content-Encoding 正确地解析出请求，都是没有问题的。 Head 请求HEAD请求常常被忽略，但是能提供很多有用的信息，特别是在有限的速度和带宽下。主要有以下特点： 1、只请求资源的首部； 2、检查超链接的有效性； 3、检查网页是否被修改； 4、多用于自动搜索机器人获取网页的标志信息，获取rss种子信息，或者传递安全认证信息等 实例，多线程下载时候可以请求资源文件大小，方便分割下载 Http缓存目前http缓存只对Get请求起作用控制缓存的Header有如下 强缓存 缓存命中返回200，不会请求服务器 Expires（已过时，会被Cache-Control覆盖）Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。 Cache-ControlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。 private: 客户端可以缓存 public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的） max-age=xxx: 缓存的内容将在 xxx 秒后失效 no-cache: 需要使用对比缓存来验证缓存数据） no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发 对比缓存，也称为协商缓存 协商缓存就是由服务器来确定缓存资源是否可用，所以要请求服务器 在缓存生效时，服务器返回状态码为304，并且报文大小和请求时间大大减少。服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端 通过修改时间判断，一般客户端都会携带If-Modified-Since询问服务缓存是否可用，部分客户端是根据响应头header中Date和 Last-Modified的差值10%作为缓存时间周期，这期间不会请求网络，只访问缓存。缓存有效返回304。 Last-Modified 只存在响应头 告诉客户端资源的最后修改时间 If-Modified-Since 只存在请求头，值来源于缓存中响应头Last-Modified的值 通过唯一标示是否匹配判断，类似java中比较hashcode判断对象是否相同,Etag优先级高于 Last-Modified，每次都会请求网络，缓存可用时返回304和响应头，同时响应body中中无数据 Etag 当前资源在服务器的唯一标识（生成规则由服务器决定），只存在响应头中 If-None-Match 请求的时候加入的header，来源于缓存的响应头Etag值，只存在请求头中 HTTP/22009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。 特性 二进制协议HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。 多工 HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。 连接共享，多路服用客户端和服务器可以把HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来 因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。 数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。 请求优先级客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 头信息压缩 HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。 HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 服务器推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中字符串比较]]></title>
    <url>%2F2017%2F11%2F25%2Fshell%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[判断字符串相等不相等方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#测试各种字符串比较操作。#shell中对变量的值添加单引号，爽引号和不添加的区别：对类型来说是无关的，即不是添加了引号就变成了字符串类型，#单引号不对相关量进行替换，如不对$符号解释成变量引用，从而用对应变量的值替代，双引号则会进行替代#author:tenfyguo A="$1"B="$2" echo "输入的原始值：A=$A,B=$B" #判断字符串是否相等if [ "$A" = "$B" ];thenecho "[ = ]"fi #判断字符串是否相等，与上面的=等价if [ "$A" == "$B" ];thenecho "[ == ]"fi #注意:==的功能在[[]]和[]中的行为是不同的，如下 #如果$a以”a”开头(模式匹配)那么将为true if [[ "$A" == a* ]];thenecho "[[ ==a* ]]"fi #如果$a等于a*(字符匹配),那么结果为trueif [[ "$A" == "a*" ]];thenecho "==/"a*/""fi #File globbing(通配) 和word splitting将会发生, 此时的a*会自动匹配到对应的当前以a开头的文件#如在当前的目录中有个文件：add_crontab.sh,则下面会输出ok#if [ "add_crontab.sh" == a* ];then #echo "ok"#fiif [ "$A" == a* ];thenecho "[ ==a* ]"fi #如果$a等于a*(字符匹配),那么结果为trueif [ "$A" == "a*" ];thenecho "==/"a*/""fi #字符串不相等if [ "$A" != "$B" ];thenecho "[ != ]"fi #字符串不相等if [[ "$A" != "$B" ]];thenecho "[[ != ]]"fi #字符串不为空，长度不为0if [ -n "$A" ];thenecho "[ -n ]"fi #字符串为空.就是长度为0.if [ -z "$A" ];thenecho "[ -z ]"fi #需要转义&lt;，否则认为是一个重定向符号if [ $A /&lt; $B ];thenecho "[ &lt; ]" fi if [[ $A &lt; $B ]];thenecho "[[ &lt; ]]" fi #需要转义&gt;，否则认为是一个重定向符号if [ $A /&gt; $B ];thenecho "[ &gt; ]" fi if [[ $A &gt; $B ]];thenecho "[[ &gt; ]]" fi 字符串包含关系方法一：利用grep查找 123456789strA=&quot;long string&quot;strB=&quot;string&quot;result=$(echo $strA | grep &quot;$&#123;strB&#125;&quot;)if [[ &quot;$result&quot; != &quot;&quot; ]]then echo &quot;包含&quot;else echo &quot;不包含&quot;fi 先打印长字符串，然后在长字符串中 grep 查找要搜索的字符串，用变量result记录结果 如果结果不为空，说明strA包含strB。如果结果为空，说明不包含。 这个方法充分利用了grep 的特性，最为简洁。 方法二：利用字符串运算符 复制代码12345678strA=&quot;helloworld&quot;strB=&quot;low&quot;if [[ $strA =~ $strB ]]then echo &quot;包含&quot;else echo &quot;不包含&quot;fi 利用字符串运算符 =~ 直接判断strA是否包含strB。（这不是比第一个方法还要简洁吗摔！） 方法三：利用通配符 12345678A=&quot;helloworld&quot;B=&quot;low&quot;if [[ $A == *$B* ]]then echo &quot;包含&quot;else echo &quot;不包含&quot;fi 这个也很easy，用通配符*号代理strA中非strB的部分，如果结果相等说明包含，反之不包含。 方法四：利用case in 语句123456thisString=&quot;1 2 3 4 5&quot; # 源字符串searchString=&quot;1 2&quot; # 搜索字符串case $thisString in *&quot;$searchString&quot;*) echo Enemy Spot ;; *) echo nope ;;esa 这个就比较复杂了，case in 我还没有接触到，不过既然有比较简单的方法何必如此 方法五：利用替换 123456789101112STRING_A=$1STRING_B=$2if [[ $&#123;STRING_A/$&#123;STRING_B&#125;//&#125; == $STRING_A ]] then ## is not substring. echo N return 0 else ## is substring. echo Y return 1 fi 判断字符串是否以cn开头123456if [[ $&#123;var:0:2&#125; -eq &quot;cn&quot; ]]thenecho sub is chinese $&#123;var:0:2&#125;elseecho sub is english $&#123;var:0:2&#125;fi 逻辑运算符、逻辑表达式详解shell的逻辑运算符 涉及有以下几种类型，因此只要适当选择，可以解决我们很多复杂的判断，达到事半功倍效果。 一、逻辑运算符 逻辑卷标 表示意思 1. 关于档案与目录的侦测逻辑卷标！ -f 常用！侦测『档案』是否存在 eg: if [ -f filename ] -d 常用！侦测『目录』是否存在 -b 侦测是否为一个『 block 档案』 -c 侦测是否为一个『 character 档案』 -S 侦测是否为一个『 socket 标签档案』 -L 侦测是否为一个『 symbolic link 的档案』 -e 侦测『某个东西』是否存在！ 2. 关于程序的逻辑卷标！ -G 侦测是否由 GID 所执行的程序所拥有 -O 侦测是否由 UID 所执行的程序所拥有 -p 侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！） 3. 关于档案的属性侦测！ -r 侦测是否为可读的属性 -w 侦测是否为可以写入的属性 -x 侦测是否为可执行的属性 -s 侦测是否为『非空白档案』 -u 侦测是否具有『 SUID 』的属性 -g 侦测是否具有『 SGID 』的属性 -k 侦测是否具有『 sticky bit 』的属性 4. 两个档案之间的判断与比较 ；例如[ test file1 -nt file2 ] -nt 第一个档案比第二个档案新 -ot 第一个档案比第二个档案旧 -ef 第一个档案与第二个档案为同一个档案（ link 之类的档案） 5. 逻辑的『和(and)』『或(or)』 &amp;&amp; 逻辑的 AND 的意思 &#124;&#124; 逻辑的 OR 的意思 运算符号 代表意义 = 等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串 != 不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串 &lt; 小于 应用于：整型比较 在[] 中，不能使用 表示字符串 &gt; 大于 应用于：整型比较 在[] 中，不能使用 表示字符串 -eq 等于 应用于：整型比较 -ne 不等于 应用于：整型比较 -lt 小于 应用于：整型比较 -gt 大于 应用于：整型比较 -le 小于或等于 应用于：整型比较 -ge 大于或等于 应用于：整型比较 -a 双方都成立（and） 逻辑表达式 –a 逻辑表达式 -o 单方成立（or） 逻辑表达式 –o 逻辑表达式 -z 空字符串 -n 非空字符串 二、逻辑表达式 test 命令 使用方法：test EXPRESSION 如： [root@localhost ~]# test 1 = 1 &amp;&amp; echo ‘ok’ok [root@localhost ~]# test -d /etc/ &amp;&amp; echo ‘ok’ok [root@localhost ~]# test 1 -eq 1 &amp;&amp; echo ‘ok’ok [root@localhost ~]# if test 1 = 1 ; then echo ‘ok’; fiok 注意：所有字符 与逻辑运算符直接用“空格”分开，不能连到一起。 精简表达式 [] 表达式 [root@localhost ~]# [ 1 -eq 1 ] &amp;&amp; echo ‘ok’ok [root@localhost ~]# [ 2 &lt; 1 ] &amp;&amp; echo ‘ok’-bash: 2: No such file or directory [root@localhost ~]# [ 2 \&lt; 1 ] &amp;&amp; echo ‘ok’ [root@localhost ~]# [ 2 -gt 1 -a 3 -lt 4 ] &amp;&amp; echo ‘ok’ ok [root@localhost ~]# [ 2 -gt 1 &amp;&amp; 3 -lt 4 ] &amp;&amp; echo ‘ok’-bash: [: missing `]’ 注意：在[] 表达式中，常见的&gt;,&lt;需要加转义字符，表示字符串大小比较，以acill码 位置作为比较。 不直接支持&lt;&gt;运算符，还有逻辑运算符|| &amp;&amp; 它需要用-a[and] –o[or]表示 [[]] 表达式 [root@localhost ~]# [ 1 -eq 1 ] &amp;&amp; echo ‘ok’ok [root@localhost ~]$ [[ 2 &lt; 3 ]] &amp;&amp; echo ‘ok’ok [root@localhost ~]$ [[ 2 &lt; 3 &amp;&amp; 4 &gt; 5 ]] &amp;&amp; echo ‘ok’ok 注意：[[]] 运算符只是[]运算符的扩充。能够支持&lt;,&gt;符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：|| &amp;&amp; 1234567891011121314151617181920212223242526272829303132333435363738394041echo &quot;========= 逻辑表达式 test =========&quot;#注意：所有字符与逻辑运算符直接用“空格”分开，不能连到一起。if test 3 -eq 3 -a 3 == 3 ;then echo &quot;true&quot; ;fi#当3 大于 2 或 4 大于 3 并且 bxp 不等于 bixiaopeng 或 变量website不为空时,为真if test 3 &gt; 2 -a 4 -gt 2 -a &quot;bxp&quot; != &quot;bixiaopeng&quot; -o -n &quot;$website&quot; ;then echo &quot;true&quot;; else echo &quot;false&quot;; fi#判断文件是否存在if test -f &quot;/Users/bixiaopeng/justtest.txt&quot; ;then echo &quot;true&quot;; else echo &quot;false&quot;; fi#判断目录是否存在if test -d &quot;/Users/bixiaopeng&quot; ;then echo &quot;true&quot;; else echo &quot;false&quot;; fiecho &quot;========= 逻辑表达式 [] =========&quot;#在[] 表达式中，常见的&gt;,&lt;需要加转义字符，表示字符串大小比较，以acill码位置作为比较。#不直接支持&lt;&gt;运算符，还有逻辑运算符 || 和 &amp;&amp; 它需要用-a[and] –o[or]表示。if [ 3 -eq 3 -a 3 == 3 ];then echo &quot;true&quot; ;fi#当3 大于 2 或 4 大于 3 并且 bxp 不等于 bixiaopeng 或 变量website不为空时,为真if [ 3 \&gt; 2 -a 4 -gt 2 -a &quot;bxp&quot; != &quot;bixiaopeng&quot; -o -n &quot;$website&quot; ] ;then echo &quot;true&quot;; else echo &quot;false&quot;; fi#判断文件是否存在if [ -f &quot;/Users/bixiaopeng/justtest.txt&quot; ] ;then echo &quot;true&quot;; else echo &quot;false&quot;; fi#判断目录是否存在if [ -d &quot;/Users/bixiaopeng&quot; ] ;then echo &quot;true&quot;; else echo &quot;false&quot;; fiecho &quot;========= 逻辑表达式 [[]] =========&quot;#[[]] 运算符只是[]运算符的扩充。能够支持&lt;,&gt;符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符 || 和 &amp;&amp;if [[ 3 -eq 3 &amp;&amp; 3 == 3 ]];then echo &quot;true&quot; ;fi#当3 大于 2 或 4 大于 3 并且 bxp 不等于 bixiaopeng 或 变量website不为空时,为真if [[ 3 &gt; 2 &amp;&amp; 4 -gt 2 &amp;&amp; &quot;bxp&quot; != &quot;bixiaopeng&quot; || -n &quot;$website&quot; ]] ;then echo &quot;true&quot;; else echo &quot;false&quot;; fi#判断文件是否存在if [[ -f &quot;/Users/bixiaopeng/justtest.txt&quot; ]] ;then echo &quot;true&quot;; else echo &quot;false&quot;; fi#判断目录是否存在if [[ -d &quot;/Users/bixiaopeng&quot; ]] ;then echo &quot;true&quot;; else echo &quot;false&quot;; fi#[[]] 中可以使用通配符,不需要引号[[ $myname = b*peng ]] &amp;&amp; echo &quot;true&quot; 三、性能比较 bash的条件表达式中有三个几乎等效的符号和命令：test，[]和[[]]。通常，大家习惯用if [];then这样的形式。而[[]]的出现，根据ABS所说，是为了兼容&gt;&lt;之类的运算符。以下是比较它们性能，发现[[]]是最快的。 $ time (for m in {1..100000}; do test -d .;done;)real 0m0.658suser 0m0.558ssys 0m0.100s $ time (for m in {1..100000}; do [ -d . ];done;)real 0m0.609suser 0m0.524ssys 0m0.085s $ time (for m in {1..100000}; do [[ -d . ]];done;)real 0m0.311suser 0m0.275ssys 0m0.036s 不考虑对低版本bash和对sh的兼容的情况下，用[[]]是兼容性强，而且性能比较快，在做条件运算时候，可以使用该运算符。 Shell脚本中判断输入变量或者参数是否为空的方法 判断变量 123456read -p &quot;input a word :&quot; wordif [ ! -n &quot;$word&quot; ] ;then echo &quot;you have not input a word!&quot;else echo &quot;the word you input is $word&quot;fi 判断输入参数 123456#!/bin/bashif [ ! -n &quot;$1&quot; ] ;then echo &quot;you have not input a word!&quot;else echo &quot;the word you input is $1&quot;fi 直接通过变量判断 如下所示:得到的结果为: IS NULL ​12345678#!/bin/shpara1=if [ ! $para1 ]; then echo &quot;IS NULL&quot;else echo &quot;NOT NULL&quot;fi ​ 使用test判断 得到的结果就是: dmin is not set! ​123456789#!/bin/shdmin=if test -z &quot;$dmin&quot;then echo &quot;dmin is not set!&quot;else echo &quot;dmin is set !&quot;fi​ 使用””判断12345678#!/bin/sh dmin=if [ &quot;$dmin&quot; = &quot;&quot; ]then echo &quot;dmin is not set!&quot;else echo &quot;dmin is set !&quot;fi zhezhelinlinux shell 中判断字符串为空的正确方法help命令可以查看帮助 help test 正确做法： 123456789101112131415161718#!/bin/shSTRING=if [ -z &quot;$STRING&quot; ]; then echo &quot;STRING is empty&quot; fiif [ -n &quot;$STRING&quot; ]; then echo &quot;STRING is not empty&quot; fi root@james-desktop:~# ./zerostring.sh STRING is empty` 错误做法：1234567891011#!/bin/shSTRING=if [ -z $STRING ]; then echo &quot;STRING is empty&quot; fiif [ -n $STRING ]; then echo &quot;STRING is not empty&quot; fi Linux命令之exit - 退出当前shell【返回值状态】使用示例示例一 退出当前shell1[root@new55 ~]# [root@new55 ~]# exit logout 示例二 在脚本中，进入脚本所在目录，否则退出12345cd $(dirname $0) || exit 1 cd $(dirname $0) || exit 1``` 示例三 在脚本中，判断参数数量，不匹配就打印使用方式，退出 if [ “$#” -ne “2” ]; then echo “usage: $0 “ exit 2fiif [ “$#” -ne “2” ]; then echo “usage: $0 “ exit 2fi12示例四 在脚本中，退出时删除临时文件 trap “rm -f tmpfile; echo Bye.” EXITtrap “rm -f tmpfile; echo Bye.” EXIT12示例五 检查上一命令的退出码 ./mycommand.shEXCODE=$?if [ “$EXCODE” == “0” ]; then echo “O.K”fi./mycommand.shEXCODE=$?if [ “$EXCODE” == “0” ]; then echo “O.K”fi` 使用trap和kill退出整个脚本cat &gt;test.sh&lt;&lt;EOF’’ #!/bin/bash export TOP_PID=$$trap ‘exit 1’ TERM exit_script(){ kill -s TERM $TOP_PID} echo “before exit”:|exit_scriptecho “after exit”EOF chmod a+x test.sh./test.shecho $?]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>shell数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F11%2F20%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式元字符描述\将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，&ldquo;\n&rdquo;匹配\n。&ldquo;\n&rdquo;匹配换行符。序列&ldquo;\&rdquo;匹配&ldquo;\&rdquo;而&ldquo;(&rdquo;则匹配&ldquo;(&rdquo;。即相当于多种编程语言中都有的&ldquo;转义字符&rdquo;的概念。^匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配&ldquo;\n&rdquo;或&ldquo;\r&rdquo;之后的位置。$匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配&ldquo;\n&rdquo;或&ldquo;\r&rdquo;之前的位置。匹配前面的子表达式任意次。例如，zo能匹配&ldquo;z&rdquo;，&ldquo;zo&rdquo;以及&ldquo;zoo&rdquo;。等价于{0,}。+匹配前面的子表达式一次或多次(大于等于1次）。例如，&ldquo;zo+&rdquo;能匹配&ldquo;zo&rdquo;以及&ldquo;zoo&rdquo;，但不能匹配&ldquo;z&rdquo;。+等价于{1,}。?匹配前面的子表达式零次或一次。例如，&ldquo;do(es)?&rdquo;可以匹配&ldquo;do&rdquo;或&ldquo;does&rdquo;中的&ldquo;do&rdquo;。?等价于{0,1}。{n}n是一个非负整数。匹配确定的n次。例如，&ldquo;o{2}&rdquo;不能匹配&ldquo;Bob&rdquo;中的&ldquo;o&rdquo;，但是能匹配&ldquo;food&rdquo;中的两个o。{n,}n是一个非负整数。至少匹配n次。例如，&ldquo;o{2,}&rdquo;不能匹配&ldquo;Bob&rdquo;中的&ldquo;o&rdquo;，但能匹配&ldquo;foooood&rdquo;中的所有o。&ldquo;o{1,}&rdquo;等价于&ldquo;o+&rdquo;。&ldquo;o{0,}&rdquo;则等价于&ldquo;o&rdquo;。{n,m}m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，&ldquo;o{1,3}&rdquo;将匹配&ldquo;fooooood&rdquo;中的前三个o。&ldquo;o{0,1}&rdquo;等价于&ldquo;o?&rdquo;。请注意在逗号和两个数之间不能有空格。?当该字符紧跟在任何一个其他限制符（,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串&ldquo;oooo&rdquo;，&ldquo;o+?&rdquo;将匹配单个&ldquo;o&rdquo;，而&ldquo;o+&rdquo;将匹配所有&ldquo;o&rdquo;。.点匹配除&ldquo;\r\n&rdquo;之外的任何单个字符。要匹配包括&ldquo;\r\n&rdquo;在内的任何字符，请使用像&ldquo;[\s\S]&rdquo;的模式。(pattern)匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0&hellip;$9属性。要匹配圆括号字符，请使用&ldquo;(&rdquo;或&ldquo;)&rdquo;。(?:pattern)匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符&ldquo;(|)&rdquo;来组合一个模式的各个部分是很有用。例如&ldquo;industr(?:y|ies)&rdquo;就是一个比&ldquo;industry|industries&rdquo;更简略的表达式。(?=pattern)正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，&ldquo;Windows(?=95|98|NT|2000)&rdquo;能匹配&ldquo;Windows2000&rdquo;中的&ldquo;Windows&rdquo;，但不能匹配&ldquo;Windows3.1&rdquo;中的&ldquo;Windows&rdquo;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern)正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如&ldquo;Windows(?!95|98|NT|2000)&rdquo;能匹配&ldquo;Windows3.1&rdquo;中的&ldquo;Windows&rdquo;，但不能匹配&ldquo;Windows2000&rdquo;中的&ldquo;Windows&rdquo;。(?&lt;=pattern)反向肯定预查，与正向肯定预查类似，只是方向相反。例如，&ldquo;(?&lt;=95|98|NT|2000)Windows&rdquo;能匹配&ldquo;2000Windows&rdquo;中的&ldquo;Windows&rdquo;，但不能匹配&ldquo;3.1Windows&rdquo;中的&ldquo;Windows&rdquo;。(?&lt;!pattern)反向否定预查，与正向否定预查类似，只是方向相反。例如&ldquo;(?&lt;!95|98|NT|2000)Windows&rdquo;能匹配&ldquo;3.1Windows&rdquo;中的&ldquo;Windows&rdquo;，但不能匹配&ldquo;2000Windows&rdquo;中的&ldquo;Windows&rdquo;。x|y匹配x或y。例如，&ldquo;z|food&rdquo;能匹配&ldquo;z&rdquo;或&ldquo;food&rdquo;或”zood”(此处请谨慎)。&ldquo;(z|f)ood&rdquo;则匹配&ldquo;zood&rdquo;或&ldquo;food&rdquo;。[xyz]字符集合。匹配所包含的任意一个字符。例如，&ldquo;[abc]&rdquo;可以匹配&ldquo;plain&rdquo;中的&ldquo;a&rdquo;。[^xyz]负值字符集合。匹配未包含的任意字符。例如，&ldquo;[^abc]&rdquo;可以匹配&ldquo;plain&rdquo;中的&ldquo;plin&rdquo;。[a-z]字符范围。匹配指定范围内的任意字符。例如，&ldquo;[a-z]&rdquo;可以匹配&ldquo;a&rdquo;到&ldquo;z&rdquo;范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.[^a-z]负值字符范围。匹配任何不在指定范围内的任意字符。例如，&ldquo;[^a-z]&rdquo;可以匹配任何不在&ldquo;a&rdquo;到&ldquo;z&rdquo;范围内的任意字符。\b匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的&ldquo;匹配&rdquo;有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，&ldquo;er\b&rdquo;可以匹配&ldquo;never&rdquo;中的&ldquo;er&rdquo;，但不能匹配&ldquo;verb&rdquo;中的&ldquo;er&rdquo;。\B匹配非单词边界。&ldquo;er\B&rdquo;能匹配&ldquo;verb&rdquo;中的&ldquo;er&rdquo;，但不能匹配&ldquo;never&rdquo;中的&ldquo;er&rdquo;。\cx匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的&ldquo;c&rdquo;字符。\d匹配一个数字字符。等价于[0-9]。\D匹配一个非数字字符。等价于[^0-9]。\f匹配一个换页符。等价于\x0c和\cL。\n匹配一个换行符。等价于\x0a和\cJ。\r匹配一个回车符。等价于\x0d和\cM。\s匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。\S匹配任何可见字符。等价于[^ \f\n\r\t\v]。\t匹配一个制表符。等价于\x09和\cI。\v匹配一个垂直制表符。等价于\x0b和\cK。\w匹配包括下划线的任何单词字符。类似但不等价于&ldquo;[A-Za-z0-9_]&rdquo;，这里的”单词”字符使用Unicode字符集。\W匹配任何非单词字符。等价于&ldquo;[^A-Za-z0-9_]&rdquo;。\xn匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，&ldquo;\x41&rdquo;匹配&ldquo;A&rdquo;。&ldquo;\x041&rdquo;则等价于&ldquo;\x04&amp;1&rdquo;。正则表达式中可以使用ASCII编码。\num (\后跟着数字)匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，&ldquo;(.)\1&rdquo;匹配两个连续的相同字符。\n标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。\nm标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。\nml如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。\un匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&amp;copy;）。\&lt; \&gt;匹配词（word）的开始（\&lt;）和结束（\&gt;）。例如正则表达式\&lt;the\&gt;能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。( )将 ( 和 ) 之间的表达式定义为&ldquo;组&rdquo;（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。|将两个匹配条件进行逻辑&ldquo;或&rdquo;（Or）运算。例如正则表达式(him|her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。+匹配1或多个正好在它之前的那个字符。例如正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。?匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的。{i} {i,j}匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如正则表达式A[0-9]{3} 能够匹配字符”A”后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。而正则表达式[0-9]{4,6} 匹配连续的任意4个、5个或者6个数字?重复任意次，但尽可能少重复如 “acbacb” 正则 “a.*?b” 只会取到第一个”acb” 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而”acbacb”最少字符的结果就是”acb” +?重复1次或更多次，但尽可能少重复与上面一样，只是至少要重复1次?? 重复0次或1次，但尽可能少重复如 “aaacb” 正则 “a.??b” 只会取到最后的三个字符”acb”{n,m}? 重复n到m次，但尽可能少重复如 “aaaaaaaa” 正则 “a{0,3}” 因为最少是0次所以取到结果为空{n,}?重复n次以上，但尽可能少重复如 “aaaaaaaa” 正则 “a{1,}” 因为最少是1次所以取到结果为 “a” 捕获分组 先了解在正则中捕获分组的概念，其实就是一个括号内的内容 如 “(\d)\d” 而”(\d)” 这就是一个捕获分组，可以对捕获分组进行 后向引用 (如果后而有相同的内容则可以直接引用前面定义的捕获组，以简化表达式) 如(\d)\d\1 这里的”\1”就是对”(\d)”的后向引用 那捕获分组有什么用呢看个例子就知道了 如 “zery zery” 正则 \b(\w+)\b\s\1\b 所以这里的”\1”所捕获到的字符也是 与(\w+)一样的”zery”，为了让组名更有意义，组名是可以自定义名字的 “\b(?\w+)\b\s\k\b” 用”?“就可以自定义组名了而要后向引用组时要记得写成 “\k“;自定义组名后,捕获组中匹配到的值就会保存在定义的组名里 下面列出捕获分组常有的用法 表达式 介绍 “(exp)” 匹配exp,并捕获文本到自动命名的组里 “(?exp)” 匹配exp,并捕获文本到名称为name的组里 “(?:exp)” 匹配exp,不捕获匹配的文本，也不给此分组分配组号 以下为零宽断言 “(?=exp)” 匹配exp前面的位置 如 “How are you doing” 正则”(?.+(?=ing))” 这里取ing前所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为”How are you do”; “(?&lt;=exp)” 匹配exp后面的位置 如 “How are you doing” 正则”(?(?&lt;=How).+)” 这里取”How”之后所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为” are you doing”; “(?!exp)” 匹配后面跟的不是exp的位置 如 “123abc” 正则 “\d{3}(?!\d)”匹配3位数字后非数字的结果 “(?&lt;!exp)” 匹配前面不是exp的位置 如 “abc123 “ 正则 “(?&lt;![0-9])123” 匹配”123”前面是非数字的结果也可写成”(?!&lt;\d)123” 正则表达应用“^\d+$” //非负整数（正整数 + 0）“^[0-9][1-9][0-9]$” //正整数“^((-\d+)|(0+))$” //非正整数（负整数 + 0）“^-[0-9][1-9][0-9]$” //负整数“^-?\d+$” //整数“^\d+(.\d+)?$” //非负浮点数（正浮点数 + 0）“^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$” //正浮点数“^((-\d+(.\d+)?)|(0+(.0+)?))$” //非正浮点数（负浮点数 + 0）“^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$” //负浮点数“^(-?\d+)(.\d+)?$” //浮点数“^[A-Za-z]+$” //由26个英文字母组成的字符串“^[A-Z]+$” //由26个英文字母的大写组成的字符串“^[a-z]+$” //由26个英文字母的小写组成的字符串“^[A-Za-z0-9]+$” //由数字和26个英文字母组成的字符串“^\w+$” //由数字、26个英文字母或者下划线组成的字符串“^[\w-]+(.[\w-]+)@[\w-]+(.[\w-]+)+$” //email地址“^[a-zA-z]+://(\w+(-\w+))(.(\w+(-\w+)))(\?\S*)?$” //url/^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-((0-2)|(3[0|1]))$/ // 年-月-日/^((0([1-9]{1}))|(1[1|2]))/((0-2)|(3[0|1]))/(d{2}|d{4})$/ // 月/日/年“^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$” //Emil“(d+-)?(d{4}-?d{7}|d{3}-?d{8}|^d{7,8})(-d+)?” //电话号码“^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$” //IP地址^([0-9A-F]{2})(-[0-9A-F]{2}){5}$ //MAC地址的正则表达式^[-+]?\d+(.\d+)?$ //值类型正则表达式 “^\d+$” //非负整数（正整数 + 0）“^[0-9][1-9][0-9]$” //正整数“^((-\d+)|(0+))$” //非正整数（负整数 + 0）“^-[0-9][1-9][0-9]$” //负整数“^-?\d+$” //整数“^\d+(\.\d+)?$” //非负浮点数（正浮点数 + 0）“^(([0-9]+\.[0-9][1-9][0-9])|([0-9][1-9][0-9]\.[0-9]+)|([0-9][1-9][0-9]))$” //正浮点数“^((-\d+(\.\d+)?)|(0+(\.0+)?))$” //非正浮点数（负浮点数 + 0）“^(-(([0-9]+\.[0-9][1-9][0-9])|([0-9][1-9][0-9]\.[0-9]+)|([0-9][1-9][0-9])))$” //负浮点数“^(-?\d+)(\.\d+)?$” //浮点数“^[A-Za-z]+$” //由26个英文字母组成的字符串“^[A-Z]+$” //由26个英文字母的大写组成的字符串“^[a-z]+$” //由26个英文字母的小写组成的字符串“^[A-Za-z0-9]+$” //由数字和26个英文字母组成的字符串“^\w+$” //由数字、26个英文字母或者下划线组成的字符串“^[\w-]+(\.[\w-]+)@[\w-]+(\.[\w-]+)+$” //email地址“^[a-zA-z]+://(\w+(-\w+))(\.(\w+(-\w+)))(\?\S*)?$” //url]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>正则</tag>
        <tag>java正则表达式</tag>
        <tag>java正则表达</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中的数组]]></title>
    <url>%2F2017%2F08%2F25%2Fshell%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[bash 提供了一维数组变量。任何变量都可以作为一个数组；内建命令 declare 可以显式地定义数组。数组的大小没有上限，也没有限制在连续对成员引用和赋值时有什么要求。数组以整数为下标，从 0 开始。 1. 定义和初始化数组下面的示例总结了如何定义一个数组和如何来初始化数组： 12345678declare -a array #显示声明了数组arraydelcare -a array[10] #数组大小没有上限，所以定义时指定的大小会被忽略array[key]=value #array[0]=one,array[1]=twoarray=(value1 value2...) #value的形式都是[subscript]=string,下标和等号可以省略，示例如下。array=（value1 value2 value3） #array[0]=value1,array[1]=value2,array[2]=value3array=([0]=value1 [2]=value3 [3]=value[4])array=()#定义空数组array=&quot;one two three&quot; # echo $&#123;array[0|@|*]&#125;,把array变量当作数组来处理，但数组元素只有字符串本身 字符串转数组，分隔符为,逗号，12selectModules=&quot;ngr_abc,ngr_cbd,ngr_xyz&quot;libNames=(`echo $selectModules|sed -r &apos;s/,/ /g&apos;|sed -r &apos;s/\&quot;//g&apos;`) 字符串转数组，分隔符为\n换行符号，123selectModules=&quot;ngr_abc\nngr_cbd\nngr_xyz&quot;libNames=(`(echo $selectModules) |awk &apos;&#123;printf $0&quot; &quot;&#125;&apos; `)echo $&#123;libNames[0]&#125; 123selectModules=&quot;ngr_abc#ngr_cbd#ngr_xyz&quot;libNames=($(echo $selectModules | tr &apos;#&apos; &apos; &apos; | tr -s &apos; &apos;))echo $&#123;libNames[1]&#125; 读取文件 以换行符号\n 分割字符串组装成数组,每行当初数组的元素123456array=(`cat hello.txt |sed &apos;:jix;N;s/\n/ /g;b jix&apos;`)echo $&#123;array[@]&#125;#awk方式libNames=(`cat hello.txt |awk &apos;&#123;printf $0&quot; &quot;&#125;&apos;`)echo $&#123;libNames[0]&#125; 分号分割1234567891011XiaoCh=&quot;xiao;j un;yu&quot; OldIFS=$IFS IFS=$&apos;;&apos; XiaoArr=($XiaoCh) for i in $&#123;XiaoArr[@]&#125; do echo &quot;$i&quot; done IFS=$OldIFS 2. 数组的访问数组的任何元素都可以用${array[subscript]}来引用，花括号是必须的，以避免和路径扩展冲突。如果 subscript 是@或是，它扩展为array的所有成员。这两种下标只有在双引号中才不同。在双引号中，${name[]}扩展为一个词，由所有数组成员的值组成，用特殊变量IFS的第一个字符分隔数组成员；${array[@]}将array的每个成员扩展为一个词。 如果数组没有成员，${name[@]} 扩展为空串。123456789#!/bin/basharr=(&quot;one&quot; &quot;two&quot;)for i in &quot;$&#123;arr[@]&#125;&quot;do echo $&#123;i&#125;done$&#123;array[1]&#125; # $&#123;array[key]&#125; 数组index为1的元素 3. 数组的删除用unset来进行数组的删除，示例如下：12unset array[2] #删除第三个成员unset array #删除整个数组 4. 数组的长度123456$&#123;#arr[@]&#125;$&#123;#arr[*]&#125;$&#123;#array[0]&#125; #同上。 $&#123;#array[*]&#125; 、$&#123;#array[@]&#125;。注意同#&#123;array:0&#125;的区别# 取得数组单个元素的长度lengthn=$&#123;#array_name[1]&#125;#获取第二个元素的长度$&#123;#arr&#125; #错误的。这个获取的是数组第一个成员的长度。 5. 数组的”切片”操作获取数组的“子串“用${arr[@]:n:m}来表示，如果没有:m那么就获取从下标n开始到最后一个元素的“字串“，示例如下： #!/bin/bash echo ${arr[@]:2}echo ${arr[@]:1:3}echo ${arr[@]:0}#打印所有${array[@]:1} # two three four,除掉第一个元素后所有元素，那么${array[@]:0}表示所有元素 6. 关联数组shell中还可以声明一个关联数组，普通数组只能使用整数作为数组的索引，而关联数组则使用字符串作为数组的索引。这个关联数组是不是有点其它语言中的字典的意思呢，o(∩∩)o…哈哈123456789101112#!/bin/bashdeclare -A ass_arrass_arr[&quot;apple&quot;]=12ass_arr[&quot;orange&quot;]=19for t in &quot;$&#123;ass_arr[@]&#125;&quot;do echo $&#123;t&#125;doneecho &quot;ass_arr[\&quot;orange\&quot;]=&quot;$&#123;ass_arr[&quot;orange&quot;]&#125; 上面的示例输出如下： 1ass_arr[“orange”]=19 从上面的输出来看关联数组输出的顺序跟普通数组有一些不同，关联数组是从最后一个成员开始输出。关联数组使用字符串作为索引，有时候我们需要获取数组的所有索引，可以用如下的方式来获取：1234567#!/bin/bashdeclare -A ass_arrass_arr[&quot;apple&quot;]=12ass_arr[&quot;orange&quot;]=19echo $&#123;!ass_arr[@]&#125; #or $&#123;!ass_arr[*]&#125; 输出如下：1apple orange 7. 子串替换子串替换12345678910111213141516171819 array=( [0]=one [1]=two [2]=three [3]=four )#第一个匹配到的，会被删除echo $&#123;array[@] /o/m&#125;mne twm three fmur#所有匹配到的，都会被删除echo $&#123;array[@] //o/m&#125;mne twm three fmur#没有指定替换子串，则删除匹配到的子符echo $&#123;array[@] //o/&#125;ne tw three fur#替换字符串前端子串echo $&#123;array[@] /#o/k&#125;kne two three four#替换字符串后端子串echo $&#123;array[@] /%o/k&#125;one twk three four### 8. 判断数组是否包含元素 array=(abc sss ccc ddd)target=”ccc”if [[ “${array[@]}” =~ $target ]];then echo “包含”else echo “不包含”fi target=”aaaa”if echo “${array[@]}” | grep -w “$target” &amp;&gt;/dev/null; then echo “包含”;else echo “不包含”fi `]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>shell数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令与场景使用]]></title>
    <url>%2F2017%2F04%2F25%2Fgit%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简写说明git checkout -b # b -&gt; browse git branch -r # r -&gt; remote git branch -a # a -&gt; all git config -l # l -&gt; list git commit -m # m -&gt; message git 配置#查看目前git仓库中有哪些配置。 git config --list #全局设置用户名和邮箱 git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;email@example.com&quot; #系统级配置,/etc/gitconfig git config --system user.name &quot;Your Name&quot; git config --system user.email &quot;email@example.com&quot; #仓库级配置,~/.gitconifg git config --local user.email &quot;email@example.com&quot; git 仓库初始化#在当前目录下新建一个git仓库 git init # 新建一个目录，将其初始化为Git代码库 git init androidDemo git remote add origin git@github.com:YotrolZ/helloTest.git # 下载一个项目和它的整个代码历史 git clone https://github.com/521xueweihan/git-tips.git # 在androidDemo目录下载一个项目和它的整个代码历史 git clone [url] androidDemo #修改远程仓库的地址，把&lt;URL&gt;替换成新的url地址。 git remote origin set-url &lt;URL&gt; #三种方式修改远程仓库地址 #1. 修改命令 git remte origin set-url URL #2.先删后加 git remote rm origin git remote add origin git@github.com:Liutos/foobar.git # 3. 直接修改config文件 增加/删除文件# 添加指定文件到暂存区 git add test.txt # 添加多个文件，中间用空格隔开 git add test1.txt test2.txt #添加带有路径的文件 git add 2017/04/hexo和githubpage搭建个人博客.md #添加当前目录下所有文件到暂存区 git add . #同样功能的命令，添加当前目录所有文件到暂存区 git add --all #以“块”形式暂存你的改动 #添加每个变化前，都会要求确认 #对于同一个文件的多处变化，可以实现分次提交 git add -p [path/file] #删除工作区文件，并将这次删除放入暂存区 git rm [filename] #删除暂存区文件，停止追踪文件，但是该文件会保留在工作区 git rm --cached [file] 关于git add -p filename这个命令 途中看到我更改了三个区块，删除了import和main两行，增加了aaa这一行，增加了abc和ddd这两行。图中有这一行 Stage this hunk [y,n,q,a,d,/,s,e,?]? 让我选择命令，详细的命令解释如下。我输入了s，表示分割，最后分割为三块， y - stage this hunk n - do not stage this hunk q - quit; do not stage this hunk or any of the remaining ones a - stage this hunk and all later hunks in the file d - do not stage this hunk or any of the later hunks in the file g - select a hunk to go to / - search for a hunk matching the given regex j - leave this hunk undecided, see next undecided hunk J - leave this hunk undecided, see next hunk k - leave this hunk undecided, see previous undecided hunk K - leave this hunk undecided, see previous hunk s - split the current hunk into smaller hunks e - manually edit the current hunk ? - print help 然后每块的操作都要询问我，让我输入命令 如图可以看到最后提交到暂存区的只有第一块 重命名/移动文件和文件夹# 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] #移动文件到文件夹 git mv xx1.js js/ #将文件夹移动到另一个文件夹下,其实相当于文件夹重命名 git mv app/ androidDemo/app #重命名本地分支： git branch -m devel develop #在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。 例如下面的例子中，我需要把 devel 分支重命名为 develop 分支： git push --delete origin devel git branch -m devel develop git push origin develop 提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区， # Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，跳过 git add。 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 分支#设置git push,pull默认的提交获取分支,这样就很方便的使用git push 提交信息或git pull获取信息 #常用于本地新建分支 git branch --set-upstream-to=origin/dev #取消对master的跟踪 git branch --unset-upstream master # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 列出所有本地分支和远程分支 git branch -a # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 新建一个分支，指向指定commit git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch] # 本地没有master分支，新建master 分支，与远程master分支建立追踪关系 git checkout --track -b master origin/master # 切换到指定分支，并更新工作区 git checkout [branch-name] #对比分区的区别 git diff branch1 branch2 # 切换到上一个分支 git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 git merge [branch] # 选择一个commit，合并进当前分支 git cherry-pick [commit] # 删除分支,如果分支没有合并，删除失败 git branch -d [branch-name] # 删除分支，即使没有合并，仍然可以删除 git branch -D [branch-name] # 删除远程分支 git push origin --delete [branch-name] git branch -dr [remote/branch] git push origin :&lt;branchName&gt; #删除不存在对应远程分支的本地分支 git fetch -p #重命名分支,不会覆盖已经存在的同名分支 git branch -m original-branch newbranch #重命名分支，会覆盖已经存在的同名分支 git branch -M original-branch newbranch #基于哈希创建新分支 #可用于查看某个历史断面 git branch emputy bfe57de0 #基于标签创建新分支 git branch [tag] emputy #查看合并的分支 git branch --merged #查看未合并的分支 ggit branch --no-merged 标签# 列出所有tag git tag # 新建一个tag在当前commit git tag [tag] #缩略commitID并单行显示提交信息 git log --pretty=oneline --abbrev-commit # 新建一个tag在指定commit git tag [tag] [commitID] #创建带有说明的标签，-a指定标签名，-m指定说明文字。 git tag -a v0.1 -m &quot;version 0.1 released&quot; [commitID] # 删除本地tag git tag -d [tag] # 删除远程tag git push origin :refs/tags/[tagName] # 查看tag信息 git show [tag] # 提交指定tag git push [remote] [tag] # 提交所有tag git push [remote] --tags # 新建一个分支，指向某个tag git checkout -b [branch] [tag] # 推送标签1.0到远程 git push origin v1.0 # 推送所有的标签到远程 git push origin --tags # 删除远程标签，但是前提是要先在本地删除对应标签。 git push origin :refs/tags/v0.9 查看信息# 显示有变更的文件 $ git status #简短方式 git status -s # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog log支持的选项参考 选项 说明 -p 按补丁格式显示每个更新之间的差异 –word-diff 按 word diff 格式显示差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –graph 显示 ASCII 图形表示的分支合并历史。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 –oneline –pretty=oneline –abbrev-commit 的简化用法。 diff命令详解 # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] #显示出所有有差异的文件列表 $ git diff branch1 branch2 --stat #将两个分支不同内容输出到foo.diff 文件中，用notepad++/sublime 之类的编辑器打开，高亮颜色 $ git diff branch1 branch2 --color &gt; foo.diff #显示当前目录下的lib目录和上次提交之间的差别（更准确的说是在当前分支下） $ git diff HEAD -- ./lib #、比较上次提交commit和上上次提交 $ git diff HEAD^ HEAD #直接将两个分支上最新的提交做diff $ git diff topic master 或 git diff topic..master #如果你想查看将要合并的某个分枝会有什么样的变化，将branch替换为你想要合并的分枝名即可 $ git diff ...(branch) 远程仓库同步#查看远程仓库 git remote -v #添加远程仓库 git remote add [name] [repository-url] #删除远程仓库 git remote rm [name] #修改远程仓库地址： git remote set-url origin new-repository-url #拉取远程仓库： #pull与fetch的区别是pull会自动merge，fetch不会 git pull [remoteName] [localBranchName] #推送远程仓库： git push [remoteName] [localBranchName] #将当前分支推送到远端master分支 git push -u orgin master #将本地 test 分支提交到远程 master 分支 #(把本地的某个分支 test 提交到远程仓库，并作为远程仓库的 master 分支) git push origin test:master #提交本地 test 分支作为#远程的 test 分支 : git push origin test:test # 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --force # 推送所有分支到远程仓库 git push [remote] --all 撤销错误的修改和提交#撤销一个已经提交的快照 #需要修复一个公共提交，git revert命令正是被设计来做这个的。 #确保你只对本地的修改使用git reset git revert [commitID] #checkout 有三个不同作用， 检出文件、检出提交和检出分支 #检出最新版文件 git checkout HEAD [filename] #检出某次提交的文件，会覆盖工作区同名文件，并显示除待提交状态 git checkout [commitID] &lt;file&gt; #检出某次提交所有文件，相当于查看历史版本的文件 #工作区和暂存区内容和那次提交之后内容相同 git checkout [commitID] #检出打标签时文件内容 git checkout [tag] #如果查看完历史版本文件内容，想回到最新提交文件内容 git checkout [branchName] # 恢复暂存区的所有文件到工作区 git checkout . #比如你删除了index.html，使用以下命令恢复文件，也可以恢复之前修改过的 git checkout -- index.html #git reset 仅仅用于未提交远程仓库的撤销操作 #如果已经提交远程仓库请用 git revert #git reset --hard HEAD^ reset index and working directory , 以来所有的变更全部丢弃，并将 HEAD 指向 #git reset --soft HEAD^ nothing changed to index and working directory ,仅仅将 HEAD 指向 ，所有变更显示在 “changed to be committed”中 #git reset --mixed HEAD^ default,reset index ,nothing to working directory 默认选项，工作区代码不改动，添加变更到index区 # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 #有时我们会不小心git add,取消某些add的文件。(还原暂存区) git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 # 相当于删除了未提交的更改，而且是同时删除了暂存区和工作区 git reset --hard #重设缓冲区，匹配最近的一次提交，但工作目录不变 git reset # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --hard [commit] #只更改引用的指向，不改变暂存区和工作区 git reset --soft &lt;commit&gt; # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git reset --keep [commit] git resetgit reset 有3个选项. –soft 不会影响到工作目录还有暂存区里的东西 –hard 工作目录，暂存区直接重置到指定的提交状态 –mixed 默认选项，会把暂存区里的东西重置到指定提交状态，并且指针指向这个提交。 一般情况, 如果你发现commit文件是存在bug情况，你只需要修改文件代码，那就用默认的mixed，hard会重置文件的内容到指定的commit，也就是说你的之前写的代码会被重置删除掉，切记。 git reset [--soft | --mixed | --hard] [-q] [&lt;commit&gt;] 其他命令git blame -w # 忽略移除空白这类改动 git blame -M # 忽略移动文本内容这类改动 git blame -C # 忽略移动文本内容到其它文件这类改动 # 执行一次git clean的『演习』。它会告诉你那些文件在命令执行后会被移除，而不是真的删除它。 git clean -n # 移除当前目录下未被跟踪的文件 git clean -f #移除未跟踪的文件，但限制在某个路径下。 git clean -f &lt;path&gt; #移除未跟踪的文件，以及目录。 git clean -df #移除当前目录下未跟踪的文件，以及Git一般忽略的文件。 git clean -xf 保存修改恢复进度文件#git stash 是保存的暂存区文件，如果你不将工作区修改文件add进暂存区 #这些未添加的文件不会被保存，或者显示`No local changes to save` #git stash保存多个的时候，新增的一个Index永远是0，由近及远index递增。 # 将工作区现场储藏起来，等以后恢复后继续工作。通常用于处理更为着急的任务时，例如：bug。 git stash #查看保存的工作现场 git stash list #查看保存的工作现场详情 $ git stash show -p stash@{0} #恢复工作现场,但不删除 git stash apply #删除stash内容,只清除一条，而且是最新添加的，也就是index为0的那条 git stash drop #恢复的同时直接删除stash内容 git stash pop #恢复指定的工作现场，当你保存了不只一份工作现场时。 git stash apply stash@{0} #就是清空所有暂存区的记录 git stash clear 别名使用如下方法为命令设置别名 git config --global alias.(name) &quot;(command)&quot; 别名进行了一些整理修改，这是我现在的.gitconfig里的别名配置： [alias] st = status -sb co = checkout br = branch mg = merge ci = commit ds = diff --staged dt = difftool mt = mergetool last = log -1 HEAD latest = for-each-ref --sort=-committerdate --format=\&quot;%(committername)@%(refname:short) [%(committerdate:short)] %(contents)\&quot; ls = log --pretty=format:\&quot;%C(yellow)%h %C(blue)%ad %C(red)%d %C(reset)%s %C(green)[%cn]\&quot; --decorate --date=short hist = log --pretty=format:\&quot;%C(yellow)%h %C(red)%d %C(reset)%s %C(green)[%an] %C(blue)%ad\&quot; --topo-order --graph --date=short type = cat-file -t dump = cat-file -p lg = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative findstr = git rev-list --all | xargs git grep -F 组合拳删除已经合并到master的分支git branch --merged master | grep -v &apos;^\*\| master&apos; | xargs -n 1 git branch -d 忽略一个已经提交的文件#假设你不小心上传local.properties这个文件 #忽略对这个文件的追踪，就要用到下面的命令，同时在.gitignore中添加忽略 git update-index --assume-unchanged (path/file) 创建一个新的空分支这里以github的操作为例，下面试图创建一个名为gh-pages的空分支 $cd repo $ git checkout --orphan gh-pages # 创建一个orphan的分支，这个分支是独立的 Switched to a new branch \&apos;gh-pages\&apos; git rm -rf . # 删除原来代码树下的所有文件 rm \&apos;.gitignore\&apos; 注意这个时候你用git branch命令是看不见当前分支的名字的，除非你进行了第一次commit。 下面我们开始添加一些代码文件，例如这里新增了一个index.html $ git add -A $ git commit -a -m \&quot;First pages commit\&quot; $ git push origin gh-pages 在commit操作之后，你就可以用git branch命令看到新分支的名字了，然后push到远程仓库 merge和rebase的区别和使用场景参考这篇文章 2.7-重写项目历史 把A分支的某一个commit，放到B分支上这个过程需要cherry-pick命令，参考 git checkout &amp;&amp; git cherry-pick 压缩多个Commit压缩两个commit git rebase -i HEAD~2 永久删除文件(包括历史记录)如果我们在git远程仓库不小心保存了账号密码或者其他机密或敏感信息文件，我们可以用以下步骤来进行补救 1.重写每个分支的历史 git filter-branch --force --index-filter &apos;git rm --cached --ignore-unmatch path-to-your-remove-file&apos; --prune-empty --tag-name-filter cat -- --all 如果看到类似下面这样表示成功了 Rewrite 48dc599c80e20527ed902928085e7861e6b3cbe6 (266/266) # Ref &apos;refs/heads/master&apos; was rewritten 如果看到这样，表示路径有问题，删除失败了 WARNING: Ref &apos;refs/heads/master&apos; is unchanged WARNING: Ref &apos;refs/remotes/origin/master&apos; is unchanged WARNING: Ref &apos;refs/remotes/origin/master&apos; is unchanged WARNING: Ref &apos;refs/stash&apos; is unchange 2.添加忽略文件 用代码，或者手动在.gitignore添加都可以 echo (filename) &gt;&gt; .gitignore git add .gitignore git commit -m &quot;Add sensitive (filename) file to gitignore&quot; 3.强制push到远程仓库 git push origin master --force 4.清理和回收空间虽然上面我们已经删除了文件, 但是我们的repo里面仍然保留了这些objects, 等待垃圾回收(GC), 所以我们要用命令彻底清除它, 并收回空间. rm -rf .git/refs/original/ git reflog expire --expire=now --all git gc --prune=now git gc --aggressive --prune=now 输出最后一次提交的改变到压缩包中git archive -o ../updated.zip HEAD $(git diff --name-only HEAD^) #输出两个提交间的改变 git archive -o ../latest.zip NEW_COMMIT_ID_HERE $(git diff --name-only OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE) 检测你的分支的改变是否为其它分支的一部分cherry命令让我们检测你的分支的改变是否出现在其它一些分支中。它通过+或者-符号来显示从当前分支与所给的分支之间的改变：是否合并了(merged)。.+ 指示没有出现在所给分支中，反之，- 就表示出现在了所给的分支中了。这里就是如何去检测： git cherry -v OTHER_BRANCH_NAME_HERE #例如: 检测master分支 git cherry -v master 使用rebase推送而非merge如果您正在团队中工作并且整个团队都在同一条branch上面工作，那么您就得经常地进行fetch/merge或者pull。Git中，分支的合并以所提交的merge来记录，以此表明一条feature分支何时与主分支合并。但是在多团队成员共同工作于一条branch的情形中，常规的merge会导致log中出现多条消息，从而产生混淆。因此，您可以在pull的时候使用rebase，以此来减少无用的merge消息，从而保持历史记录的清晰。 git pull --rebase 您也可以将某条branch配置为总是使用rebase推送： git config branch.BRANCH_NAME_HERE.rebase true 远程分支回滚到某个commit$ git checkout the_branch $ git pull $ git branch the_branch_backup //备份一下这个分支当前的情况 $ git reset --hard the_commit_id //把the_branch本地回滚到the_commit_id $ git push origin :the_branch //删除远程 the_branch $ git push origin the_branch //用回滚后的本地分支重新建立远程分支 $ git push origin :the_branch_backup //如果前面都成功了，删除这个备份分支 git将单个文件恢复到历史版本的正确方法如下：$ git reset commit_id 文件路径 $ git checkout -- 文件路径 git reflogGit reflog 可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录commit1: add Test1.javacommit2: add Test2.javacommit3: add Test2.java #删除commit3的提交 $ git reset --hard HEAD~1 #如果恢复commit3的提交，就要查看commitid $ git reflog 3e94c18ae HEAD@{0}: commit: add Test3.java e55c2974f HEAD@{1}: commit: add Test2.java 3e94c18ae HEAD@{2}: commit: add Test1.java #恢复删除的commit3 有两种方式 $ git reset --hard 3e94c18ae #第二种方式 $ git cherry-pick 3e94c18ae 修改远程仓库地址方法有三种： 修改命令 git remote set-url origin [url] #我这里使用 git remote set-url origin [url]命令，直接修改远程仓库为https的地址 先删后加 shell git remote rm origin git remote add origin [url] 直接修改config文件 以上进行git操作的时候，每次都需要密码，所以可以配置免密1）新建文件并保存密码$ touch ~/.git-credentials$ vim ~/.git-credentials2）添加内容https://{username}:{passwd}@github.com3）添加git配置$ git config –global credential.helper store 删除文件历史记录参考文章http://www.cnblogs.com/shines77/p/3460274.html 12345678910111213$ git filter-branch --force --index-filter &apos;git rm --cached --ignore-unmatch gradle.properties&apos; --prune-empty --tag-name-filter cat -- --all$ git push origin master --force$ git push origin master --force --tags$ rm -rf .git/refs/original/$ git reflog expire --expire=now --all$ git gc --prune=now$ git gc --aggressive --prune=now 只拉取仓库中的一个文件1234567git init &lt;repo&gt;cd &lt;repo&gt;git remote add origin &lt;url&gt;git config core.sparsecheckout trueecho &quot;finisht/*&quot; &gt;&gt; .git/info/sparse-checkoutecho &quot;another/sub/tree&quot; &gt;&gt; .git/info/sparse-checkoutgit pull --depth=1 origin master 删除文件夹在git记录1234567891011#文件夹名为.ideagit filter-branch --force --index-filter &quot;git rm --cached -r --ignore-unmatch .idea&quot; --prune-empty --tag-name-filter cat -- --allgit push --force --allrm -rf .git/refs/original/git reflog expire --expire=now --allgit gc --prune=nowgit gc --aggressive --prune=now 参考文章 https://www.ibm.com/developerworks/cn/devops/d-learn-workings-git/index.html git学习圣经https://git-scm.com/book/zh/v2 常用 Git 命令清单 阮一峰的网络日志 http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html https://juejin.im/post/58f817b55c497d0058e0926a https://github.com/xirong/my-git/blob/master/useful-git-command.md https://github.com/geeeeeeeeek/git-recipes/wiki 试试Git – 15分钟的Git交互教程https://try.github.io/levels/1/challenges/1 git奇技淫巧https://github.com/521xueweihan/git-tips Git Community Book 中文版http://gitbook.liuhui998.com/index.html http://iissnan.com/progit/ https://git-scm.com/book/zh/v2/ http://gitbook.liuhui998.com/index.html https://github.com/ruijun/Android-Dev-Favorites/blob/master/Git/Git.md http://www.jianshu.com/p/da3ee7d07a03 commit是如何填message&lt;http://mp.weixin.qq.com/s?__biz=MzAwNDYwNzU2MQ==&amp;mid=401622986&amp;idx=1&amp;sn=470717939914b956ac372667ed23863c&amp;scene=2&amp;srcid=0114ZcTNyAMH8CLwTKlj6CTN&amp;from=timeline&amp;isappinstalled=0#wechat_re direct&gt;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git命令</tag>
        <tag>git教程</tag>
        <tag>git详解</tag>
        <tag>git学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓开发规范]]></title>
    <url>%2F2017%2F04%2F25%2F%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[安卓开发规范(updating)摘要 1 前言 2 AS规范 3 命名规范 4 资源文件规范 5 版本统一规范 6 第三方库规范 7 注释规范 8 测试规范 9 RN规范 10 其他的一些规范 1 前言为了利于项目维护以及规范开发，促进成员之间Code Review的效率，故提出以下开发规范，如有更好建议，欢迎到GitHub提issue，原文地址： 安卓开发规范(updating) 2 AS规范工欲善其事，必先利其器。 尽量使用最新版的IDE进行开发； 编码格式统一为UTF-8； 编辑完.java、 .xml等文件后一定要格式化（基本格式方面使用 AS 默认模板即可）； 删除多余的import，减少警告出现，可利用AS的Optimize Imports(Settings → Keymap → Optimize Imports)快捷键； AS常用开发插件可以参考这里～AS常用开发插件 3 命名规范代码中的命名严禁使用拼音与英文混合的方式,更不允许直接使用中文的方式。正确的英文拼写和语法可以让阅读者易于理解,避免歧义。 注意：即使纯拼音命名方式也要避免采用。但alibaba、taobao、youku、hangzhou等国际通用的名称,可视同英文。 3.1 包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线，采用反域名命名规则，全部使用小写字母。一级包名是顶级域名，通常为com,edu,gov,net,org等，二级包名为公司名，三级包名根据应用进行命名，后面就是对包名的划分了，关于包名的划分，推荐使用按功能分，一开始我们也是按照层去分包的，很坑爹。按照功能分可能你不是很好区分在哪个功能中，不过也比你按照层区分要好找很多。具体可以参考这篇博文～Package by features, not layers，当然，我们大谷歌也有相应的sample～iosched，其结构如下所示，很值得学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185java└─com └─google └─samples └─apps └─iosched │ AppApplication.java 定义Application类 │ Config.java 定义配置数据（常量） │ ├─about │ AboutActivity.java │ ├─appwidget │ ScheduleWidgetProvider.java │ ScheduleWidgetRemoteViewsService.java │ ├─debug │ │ DebugAction.java │ │ DebugActivity.java │ │ DebugFragment.java │ │ │ └─actions │ DisplayUserDataDebugAction.java │ ForceAppDataSyncNowAction.java │ ForceSyncNowAction.java │ ... │ ├─explore │ │ ExploreIOActivity.java │ │ ExploreIOFragment.java │ │ ExploreModel.java │ │ ... │ │ │ └─data │ ItemGroup.java │ LiveStreamData.java │ MessageData.java │ ... │ ├─feedback │ FeedbackApiHelper.java │ FeedbackConstants.java │ FeedbackHelper.java │ ... │ ├─framework │ FragmentListener.java │ LoaderIdlingResource.java │ Model.java │ ...定义interface并实现 │ ├─gcm │ │ GCMCommand.java │ │ GCMIntentService.java │ │ GCMRedirectedBroadcastReceiver.java │ │ ... │ │ │ └─command │ AnnouncementCommand.java │ NotificationCommand.java │ SyncCommand.java │ ... │ ├─io │ │ BlocksHandler.java │ │ HandlerException.java │ │ HashtagsHandler.java │ │ ...处理model │ │ │ ├─map │ │ └─model │ │ MapData.java │ │ Marker.java │ │ Tile.java │ │ │ └─model │ Block.java │ DataManifest.java │ Hashtag.java │ ... │ ├─map │ │ InlineInfoFragment.java │ │ MapActivity.java │ │ MapFragment.java │ │ ... │ │ │ └─util │ CachedTileProvider.java │ MarkerLoadingTask.java │ MarkerModel.java │ ... │ ├─model │ ScheduleHelper.java │ ScheduleItem.java │ ScheduleItemHelper.java │ ...定义model以及实现model相关操作 │ ├─myschedule │ MyScheduleActivity.java │ MyScheduleAdapter.java │ MyScheduleFragment.java │ ... │ ├─provider │ ScheduleContract.java │ ScheduleContractHelper.java │ ScheduleDatabase.java │ ...实现ContentProvider │ （也在此处定义provider依赖的其它类，比如db操作） │ ├─receiver │ SessionAlarmReceiver.java │ ├─service │ DataBootstrapService.java │ SessionAlarmService.java │ SessionCalendarService.java │ ├─session │ SessionDetailActivity.java │ SessionDetailConstants.java │ SessionDetailFragment.java │ ... │ ├─settings │ ConfMessageCardUtils.java │ SettingsActivity.java │ SettingsUtils.java │ ├─social │ SocialActivity.java │ SocialFragment.java │ SocialModel.java │ ├─sync │ │ ConferenceDataHandler.java │ │ RemoteConferenceDataFetcher.java │ │ SyncAdapter.java │ │ ... │ │ │ └─userdata │ │ AbstractUserDataSyncHelper.java │ │ OnSuccessListener.java │ │ UserAction.java │ │ ... │ │ │ ├─gms │ │ DriveHelper.java │ │ GMSUserDataSyncHelper.java │ │ │ └─util │ UserActionHelper.java │ UserDataHelper.java │ ├─ui │ │ BaseActivity.java │ │ CheckableLinearLayout.java │ │ SearchActivity.java │ │ ...BaseActivity以及自定义UI组件 │ │ │ └─widget │ AspectRatioView.java │ BakedBezierInterpolator.java │ BezelImageView.java │ ...自定义小UI控件 │ ├─util │ AboutUtils.java │ AccountUtils.java │ AnalyticsHelper.java │ ...工具类，提供静态方法 │ ├─videolibrary │ VideoLibraryActivity.java │ VideoLibraryFilteredActivity.java │ VideoLibraryFilteredFragment.java │ ... │ └─welcome AccountFragment.java AttendingFragment.java ConductFragment.java ... 参考Google I/O 2015的代码结构，按功能分包具体可以这样做： 1234567891011121314151617181920212223242526272829303132333435363738394041src└─com └─domain └─app │ AppApplication.java 定义Application类 │ Config.java 定义配置数据（常量） │ ├─framework │ 定义interface以及相关基类 │ ├─io │ 数据定义（model）、数据操作（比如json解析，但不包括db操作） │ ├─model │ 定义model（数据结构以及getter/setter、compareTo、equals等等，不含复杂操作） │ 以及modelHelper（提供便于操作model的api） │ ├─provider │ 实现ContentProvider，及其依赖的db操作 │ ├─receiver │ 实现Receiver │ ├─service │ 实现Service（比如IntentService），用于在独立线程中异步do stuff │ ├─ui │ 实现BaseActivity，以及自定义view和widget，相关的Adapter也放这里 │ ├─util │ 实现工具类，提供静态方法 │ ├─feature1 │ Item.java 定义model │ ItemHelper.java 实现modelHelper │ feature1Activity.java 定义UI │ feature1DAO.java 私有db操作 │ feature1Utils.java 私有工具函数 │ ...其它私有class │ ├─...其它feature PBF(按功能分包Package By Feature)与PBL(按层分包Package By Layer)相比较有如下优势： package内高内聚，package间低耦合 哪块要添新功能，只改某一个package下的东西 按class职能分层（PBL）降低了代码耦合，但带来了package耦合，要添新功能，需要改model、dbHelper、view、service等等，需要改动好几个package下的代码，改动的地方越多，越容易产生新问题，不是吗？ 按功能分包（PBF），featureA相关的所有东西都在featureA包，feature内高内聚高度模块化，不同feature之间低耦合，相关的东西都放在一起，还好找 package有私有作用域（package-private scope） 你负责开发这块功能，这个目录下所有东西都是你的 PBL的方式是把所有工具方法都放在util包下，小张开发新功能时候发现需要一个xxUtil，但它又不是通用的，那应该放在哪里？没办法，按照分层原则，我们还得放在util包下，好像不太合适，但放在其它包更不合适，功能越来越多，util类也越定义越多。后来小李负责开发一块功能时发现需要一个xxUtil，同样不通用，去util包一看，怎么已经有了，而且还没法复用，只好放弃xx这个名字，改为xxxUtil……因为PBL的package没有私有作用域，每一个包都是public（跨包方法调用是很平常的事情，每一个包对其它包来说都是可访问的） 如果是PBF，小张的xxUtil自然放在feautreA下，小李的xxUtil在featureB下，如果觉得util好像是通用的，就去util包看看要不要把工具方法添进xxUtil，class命名冲突没有了 PBF的package有私有作用域，featureA不应该访问featureB下的任何东西（如果非访问不可，那就说明接口定义有问题） 很容易删除功能 统计发现新功能没人用，这个版本那块功能得去掉 如果是PBL，得从功能入口到整个业务流程把受到牵连的所有能删的代码和class都揪出来删掉，一不小心就完蛋 如果是PBF，好说，先删掉对应包，再删掉功能入口（删掉包后入口肯定报错了），完事 高度抽象 解决问题的一般方法是从抽象到具体，PBF包名是对功能模块的抽象，包内的class是实现细节，符合从抽象到具体，而PBL弄反了 PBF从确定AppName开始，根据功能模块划分package，再考虑每块的具体实现细节，而PBL从一开始就要考虑要不要dao层，要不要com层等等 只通过class来分离逻辑代码 PBL既分离class又分离package，而PBF只通过class来分离逻辑代码 没有必要通过package分离，因为PBL中也可能出现尴尬的情况： 12├─service │ MainServ.java 按照PBL，service包下的所有东西都是Controller，应该不需要Serv后缀，但实际上通常为了码起来方便，直接import service包，Serv后缀是为了避免引入的class和当前包下的class命名冲突，当然，不用后缀也可以，得写清楚包路径，比如new net.ayqy.service.Main()，麻烦 而PBF就很方便，无需import，直接new MainServ()即可 package的大小有意义了 PBL中包的大小无限增长是合理的，因为功能越添越多 而PBF中包太大（包里class太多）表示这块需要重构（划分子包） 3.2 类名类名都以UpperCamelCase风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。 名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如HTML, URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。 类 描述 例如 Activity 类 Activity为后缀标识 欢迎页面类WelcomeActivity Adapter类 Adapter 为后缀标识 新闻详情适配器 NewDetailAdapter 解析类 Parser为后缀标识 首页解析类HomePosterParser 工具方法类 Utils或Manager为后缀标识（与系统或第三方的Utils区分）或功能+Utils 线程池管理类：ThreadPoolManager日志工具类：LogUtils（Logger也可）打印工具类：PrinterUtils 数据库类 以DBHelper后缀标识 新闻数据库：NewDBHelper Service类 以Service为后缀标识 时间服务TimeService BroadcastReceiver类 以Receiver为后缀标识 推送接收JPushReceiver ContentProvider类 以Provider为后缀标识 ShareProvider 自定义的共享基础类 以Base开头 BaseActivity,BaseFragment 测试类的命名以它要测试的类的名称开始，以Test结束。例如：HashTest或HashIntegrationTest。 接口（interface）：命名规则与类一样采用大驼峰命名法，多以able或ible结尾，如interface Runnable、interface Accessible。 注意：如果项目采用MVP，所有Model、View、Presenter的接口都以I为前缀，不加后缀，其他的接口采用上述命名规则。 3.3 方法名方法名都以lowerCamelCase风格编写。 方法名通常是动词或动词短语。 方法 说明 initXX() 初始化相关方法,使用init为前缀标识，如初始化布局initView() isXX() checkXX() 方法返回值为boolean型的请使用is或check为前缀标识 getXX() 返回某个值的方法，使用get为前缀标识 setXX() 设置某个属性值 handleXX()/processXX() 对数据进行处理的方法 displayXX()/showXX() 弹出提示框和提示信息，使用display/show为前缀标识 updateXX() 更新数据 saveXX() 保存数据 resetXX() 重置数据 clearXX() 清除数据 removeXX() 移除数据或者视图等，如removeView(); drawXX() 绘制数据或效果相关的，使用draw前缀标识 3.4 常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？ 每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。 1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableListNAMES = ImmutableList.of("Ed", "Ann");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = "non-final";final String nonStatic = "non-static";static final SetmutableCollection = new HashSet();static final ImmutableSetmutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;"these", "can", "change"&#125;; 3.5 非常量字段名非常量字段名以lowerCamelCase风格的基础上改造为如下风格：基本结构为scopeVariableNameType。 scope：范围 非公有，非静态字段命名以m开头。 静态字段命名以s开头。 公有非静态字段命名以p开头。 公有静态字段（全局变量）命名以g开头。 例子： 12345678public class MyClass &#123; int mPackagePrivate; private int mPrivate; protected int mProtected; private static MyClass sSingleton; public int pField; public static int gField;&#125; 使用1字符前缀来表示作用范围，1个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字母小写，这样保证了对变量名能够进行正确的断句。 Type：类型 考虑到Android中使用很多UI控件，为避免控件和普通成员变量混淆以及更好达意，所有用来表示控件的成员变量统一加上控件缩写作为后缀（文末附有缩写表）。 对于普通变量一般不添加类型后缀，如果统一添加类型后缀，请参考文末的缩写表。 用统一的量词通过在结尾处放置一个量词，就可创建更加统一的变量，它们更容易理解，也更容易搜索。 注意：如果项目中使用ButterKnife，则不添加m前缀，以lowerCamelCase风格命名。 例如，请使用mCustomerStrFirst和mCustomerStrLast，而不要使用mFirstCustomerStr和mLastCustomerStr。 量词列表 量词后缀说明 First 一组变量中的第一个 Last 一组变量中的最后一个 Next 一组变量中的下一个变量 Prev 一组变量中的上一个 Cur 一组变量中的当前变量 说明： 集合添加如下后缀：List、Map、Set数组添加如下后缀：Arr 注意：所有的VO（值对象）统一采用标准的lowerCamelCase风格编写，所有的DTO（数据传输对象）就按照接口文档中定义的字段名编写。 3.6 参数名参数名以lowerCamelCase风格编写。参数应该避免用单个字符命名。 3.7 局部变量名局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。 3.8 临时变量临时变量通常被取名为i、j、k、m和n，它们一般用于整型；c、d、e，它们一般用于字符型。 如：for (int i = 0; i &lt; len ; i++)。 3.9 类型变量名类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。 以类命名方式(参考3.2 类名)，后面加个大写的T(如：RequestT, FooBarT)。 更多还可参考～阿里巴巴Java开发手册 4 资源文件规范4.1 资源布局文件（XML文件（layout布局文件））全部小写，采用下划线命名法 4.1.1 contentView命名必须以全部单词小写，单词间以下划线分割，使用名词或名词词组。 所有Activity或Fragment的contentView必须与其类名对应，对应规则为：将所有字母都转为小写，将类型和功能调换（也就是后缀变前缀）。 例如：activity_main.xml 4.1.2 Dialog命名规则：dialog_描述.xml 例如：dialog_hint.xml 4.1.3 PopupWindow命名规则：ppw_描述.xml 例如：ppw_info.xml 4.1.4 列表项命名规则：item_描述.xml 例如：item_city.xml 4.1.5 包含项命名规则：模块_(位置)描述.xml 例如：activity_main_head.xml、activity_main_bottom.xml 注意：通用的包含项命名采用：项目名称缩写_描述.xml 例如：xxxx_title.xml 4.2 资源文件（图片drawable文件夹下）全部小写，采用下划线命名法，加前缀区分 命名模式：可加后缀 _small 表示小图， _big 表示大图，逻辑名称可由多个单词加下划线组成，采用以下规则： 用途_模块名_逻辑名称 用途_模块名_颜色 用途_逻辑名称 用途_颜色 说明：用途也指控件类型（具体见附录UI控件缩写表） 例如： 名称 说明 btn_main_home.png 按键用途_模块名_逻辑名称 divider_maket_white.png 分割线用途_模块名_颜色 ic_edit.png 图标用途_逻辑名称 bg_main.png 背景用途_逻辑名称 btn_red.png 红色按键用途_颜色 btn_red_big.png 红色大按键用途_颜色 ic_head_small.png 小头像用途_逻辑名称 bg_input.png 输入框背景用途_逻辑名称 divider_white.png 白色分割线用途_颜色 bg_main_head 主模块头部背景图片用途_模块名_逻辑名称 def_search_cell 默认搜索界面单元图片用途_模块名_逻辑名称 ic_more_help 更多帮助图标用途_逻辑名称 divider_list_line 列表分割线用途_逻辑名称 sel_search_ok 搜索界面确认选择器用途_模块名_逻辑名称 shape_music_ring 音乐界面环形形状用途_模块名_逻辑名称 如果有多种形态，如按钮选择器：sel_btn_xx.xml 名称 说明 sel_btn_xx 按钮图片使用btn_整体效果（selector） btn_xx_normal 按钮图片使用btn_正常情况效果 btn_xx_pressed 按钮图片使用btn_点击时候效果 btn_xx_focused state_focused聚焦效果 btn_xx_disabled state_enabled (false)不可用效果 btn_xx_checked state_checked选中效果 btn_xx_selected state_selected选中效果 btn_xx_hovered state_hovered悬停效果 btn_xx_checkable state_checkable可选效果 btn_xx_activated state_activated激活的 btn_xx_windowfocused state_window_focused 注意：使用AndroidStudio的插件SelectorChapek可以快速生成selector，前提是命名要规范。 4.3 动画文件（anim文件夹下）全部小写，采用下划线命名法，加前缀区分。 具体动画采用以下规则：模块名_逻辑名称。 例如：refresh_progress.xml、market_cart_add.xml、market_cart_remove.xml。 普通的tween动画采用如下表格中的命名方式：动画类型_方向 名称 说明 fade_in 淡入 fade_out 淡出 push_down_in 从下方推入 push_down_out 从下方推出 push_left 推向左方 slide_in_from_top 从头部滑动进入 zoom_enter 变形进入 slide_in 滑动进入 shrink_to_middle 中间缩小 4.4 values中name命名4.4.1 colors.xmlcolors.xml的name命名使用下划线命名法，在你的colors.xml文件中应该只是映射颜色的名称一个ARGB值，而没有其它的。不要使用它为不同的按钮来定义ARGB值。 不要这样做 123456789&lt;resources&gt; &lt;color name="button_foreground"&gt;#FFFFFF&lt;/color&gt; &lt;color name="button_background"&gt;#2A91BD&lt;/color&gt; &lt;color name="comment_background_inactive"&gt;#5F5F5F&lt;/color&gt; &lt;color name="comment_background_active"&gt;#939393&lt;/color&gt; &lt;color name="comment_foreground"&gt;#FFFFFF&lt;/color&gt; &lt;color name="comment_foreground_important"&gt;#FF9D2F&lt;/color&gt; ... &lt;color name="comment_shadow"&gt;#323232&lt;/color&gt; 使用这种格式，你会非常容易的开始重复定义ARGB值，这使如果需要改变基本色变的很复杂。同时，这些定义是跟一些环境关联起来的，如button或者comment, 应该放到一个按钮风格中，而不是在colors.xml文件中。 相反，这样做 12345678910111213141516&lt;resources&gt; &lt;!-- grayscale --&gt; &lt;color name="white" &gt;#FFFFFF&lt;/color&gt; &lt;color name="gray_light"&gt;#DBDBDB&lt;/color&gt; &lt;color name="gray" &gt;#939393&lt;/color&gt; &lt;color name="gray_dark" &gt;#5F5F5F&lt;/color&gt; &lt;color name="black" &gt;#323232&lt;/color&gt; &lt;!-- basic colors --&gt; &lt;color name="green"&gt;#27D34D&lt;/color&gt; &lt;color name="blue"&gt;#2A91BD&lt;/color&gt; &lt;color name="orange"&gt;#FF9D2F&lt;/color&gt; &lt;color name="red"&gt;#FF432F&lt;/color&gt;&lt;/resources&gt; 向应用设计者那里要这个调色板，名称不需要跟&quot;green&quot;、&quot;blue&quot;等等相同。&quot;brand_primary&quot;、&quot;brand_secondary&quot;、&quot;brand_negative&quot;这样的名字也是完全可以接受的。 像这样规范的颜色很容易修改或重构，会使应用一共使用了多少种不同的颜色变得非常清晰。 通常一个具有审美价值的UI来说，减少使用颜色的种类是非常重要的。 注意：如果某些颜色和主题有关，那就单独写一个colors_theme.xml。 4.4.2 dimens.xml像对待colors.xml一样对待dimens.xml文件 与定义颜色调色板一样，你同时也应该定义一个空隙间隔和字体大小的“调色板”。 一个好的例子，如下所示： 123456789101112131415161718192021&lt;resources&gt; &lt;!-- font sizes --&gt; &lt;dimen name="font_larger"&gt;22sp&lt;/dimen&gt; &lt;dimen name="font_large"&gt;18sp&lt;/dimen&gt; &lt;dimen name="font_normal"&gt;15sp&lt;/dimen&gt; &lt;dimen name="font_small"&gt;12sp&lt;/dimen&gt; &lt;!-- typical spacing between two views --&gt; &lt;dimen name="spacing_huge"&gt;40dp&lt;/dimen&gt; &lt;dimen name="spacing_large"&gt;24dp&lt;/dimen&gt; &lt;dimen name="spacing_normal"&gt;14dp&lt;/dimen&gt; &lt;dimen name="spacing_small"&gt;10dp&lt;/dimen&gt; &lt;dimen name="spacing_tiny"&gt;4dp&lt;/dimen&gt; &lt;!-- typical sizes of views --&gt; &lt;dimen name="button_height_tall"&gt;60dp&lt;/dimen&gt; &lt;dimen name="button_height_normal"&gt;40dp&lt;/dimen&gt; &lt;dimen name="button_height_short"&gt;32dp&lt;/dimen&gt;&lt;/resources&gt; 布局时在写margins和paddings时，你应该使用spacing_xxxx尺寸格式来布局，而不是像对待string字符串一样直接写值。 这样写会非常有感觉，会使组织和改变风格或布局是非常容易。 4.4.3 strings.xmlstrings的name命名使用下划线命名法，采用以下规则：模块名+逻辑名称，这样方便同一个界面的所有string都放到一起，方便查找。 名称 说明 main_menu_about 主菜单按键文字 friend_title 好友模块标题栏 friend_dialog_del 好友删除提示 login_check_email 登录验证 dialog_title 弹出框标题 button_ok 确认键 loading 加载文字 4.4.4 styles.xmlstyle的name命名使用大驼峰命名法，几乎每个项目都需要适当的使用style文件，因为对于一个视图来说有一个重复的外观是很常见的，将所有的外观细节属性（colors、padding、font）放在style文件中。 在应用中对于大多数文本内容，最起码你应该有一个通用的style文件，例如： 1234&lt;style name=&quot;ContentText&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;@dimen/font_normal&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@color/basic_black&lt;/item&gt;&lt;/style&gt; 应用到TextView中: 123456&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/price&quot; style=&quot;@style/ContentText&quot; /&gt; 你或许需要为按钮控件做同样的事情，不要停止在那里。将一组相关的和重复android:****的属性放到一个通用的style中。 将一个大的styles.xml文件分割成多个文件， 你可以有多个styles.xml 文件。Android SDK支持其它文件，styles.xml这个文件名称并没有作用，起作用的是在文件里的&lt;style&gt;标签。因此你可以有多个style文件，如styles.xml、styles_home.xml、styles_item_details.xml、styles_forms.xml。 不同于资源文件路径需要为系统构建起的有意义，在res/values目录下的文件可以任意命名。 4.5 layout中的id命名命名模式为：view缩写_模块名_逻辑名，比如btn_main_search使用AndroidStudio的插件ButterKnife Zelezny，生成注解非常方便，原生的话可以使用Android Code Generator插件。 如果想对资源文件进行分包可以参考我这篇文章～Android Studio下对资源进行分包 5 版本统一规范Android开发存在着众多版本的不同，比如compileSdkVersion、minSdkVersion、targetSdkVersion以及项目中依赖第三方库的版本，不同的module及不同的开发人员都有不同的版本，所以需要一个统一版本规范的文件。 具体可以参考我写的这篇博文～Android开发之版本统一规范 6 第三方库规范别再闭门造车了，用用最新最火的技术吧，安利一波～Android 流行框架查速表，顺便带上自己的干货～Android开发人员不得不收集的代码 希望Team能用时下较新的技术，对开源库的选取，一般都需要选择比较稳定的版本，作者在维护的项目，要考虑作者对issue的解决，以及开发者的知名度等各方面。选取之后，一定的封装是必要的。 个人推荐Team可使用如下优秀轮子： Retrofit RxAndroid OkHttp Glide / Fresco Gson / Fastjson EventBus / AndroidEventBus GreenDao Dagger2(选用) Tinker(选用) 7 注释规范为了减少他人阅读你代码的痛苦值，请在关键地方做好注释。 7.1 类注释每个类完成后应该有作者姓名和联系方式的注释，对自己的代码负责。 123456789101112/** * &lt;pre&gt; * author : Blankj * e-mail : xxx@xx * time : 2017/03/07 * desc : xxxx描述 * version: 1.0 * &lt;/pre&gt; */public class WelcomeActivity &#123; ...&#125; 具体可以在AS中自己配制，Settings → Editor → File and Code Templates → Includes → File Header，输入 123456789/** * &lt;pre&gt; * author : $&#123;USER&#125; * e-mail : xxx@xx * time : $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125; * desc : * version: 1.0 * &lt;/pre&gt; */ 这样便可在每次新建类的时候自动加上该头注释。 7.2 方法注释每一个成员方法（包括自定义成员方法、覆盖方法、属性方法）的方法头都必须做方法头注释，在方法前一行输入/** + 回车或者设置Fix doc comment(Settings → Keymap → Fix doc comment)快捷键，AS便会帮你生成模板，我们只需要补全参数即可，如下所示。 12345678910111213/** * bitmap转byteArr * * @param bitmap bitmap对象 * @param format 格式 * @return 字节数组 */public static byte[] bitmap2Bytes(Bitmap bitmap, CompressFormat format) &#123; if (bitmap == null) return null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); bitmap.compress(format, 100, baos); return baos.toByteArray();&#125; 7.3 块注释块注释与其周围的代码在同一缩进级别。它们可以是/* ... */风格，也可以是// ...风格(//后最好带一个空格）。对于多行的/* ... */注释，后续行必须从*开始， 并且与前一行的*对齐。以下示例注释都是OK的。 1234/* * This is // And so /* Or you can * okay. // is this. * even do this. */ */ 注释不要封闭在由星号或其它字符绘制的框架里。 Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/* ... */。 7.4 其他一些注释AS已帮你集成了一些注释模板，我们只需要直接使用即可，在代码中输入todo、fixme等这些注释模板，回车后便会出现如下注释 12// TODO: 17/3/14 需要实现，但目前还未实现的功能的说明// FIXME: 17/3/14 需要修正，甚至代码是错误的，不能工作，需要修复的说明 8 测试规范业务开发完成之后，开发人员做单元测试，单元测试完成之后，保证单元测试全部通过同时单元测试代码覆盖率达到一定程度（这个需要开发和测试约定，理论上越高越好），开发提测。 // TODO… 9 RN规范// TODO… 10 其他的一些规范 合理布局，有效运用&lt;merge&gt;、&lt;ViewStub&gt;、&lt;include&gt;标签； Activity和Fragment里面有许多重复的操作以及操作步骤，所以我们都需要提供一个BaseActivity和BaseFragment，让所有的Activity和Fragment都继承这个基类。 方法基本上都按照调用的先后顺序在各自区块中排列； 相关功能作为小区块放在一起（或者封装掉）； 当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法； 数据提供统一的入口。无论是在 MVP、MVC 还是 MVVM 中，提供一个统一的数据入口，都可以让代码变得更加易于维护。比如可使用一个DataManager，把 http、preference、eventpost、database 都放在DataManger里面进行操作，我们只需要与DataManger打交道； 多用组合, 少用继承； 提取方法, 去除重复代码。对于必要的工具类抽取也很重要，这在以后的项目中是可以重用的。 可引入 Dagger2 减少模块之间的耦合性。Dagger2 是一个依赖注入框架，使用代码自动生成创建依赖关系需要的代码。减少很多模板化的代码，更易于测试，降低耦合，创建可复用可互换的模块； 项目引入RxJava + RxAndroid这些响应式编程，可以极大的减少逻辑代码； 通过引入事件总线，如：EventBus、AndroidEventBus、RxBus，它允许我们在DataLayer中发送事件，以便ViewLayer中的多个组件都能够订阅到这些事件，减少回调； 尽可能使用局部变量； 及时关闭流； 尽量减少对变量的重复计算； 如下面的操作： 123for (int i = 0; i &lt; list.size(); i++) &#123; ...&#125; 建议替换为： 123for (int i = 0, int length = list.size(); i &lt; length; i++) &#123; ...&#125; 尽量采用懒加载的策略，即在需要的时候才创建； 例如： 1234String str = "aaa";if (i == 1) &#123; list.add(str);&#125; 建议替换为： 1234if (i == 1) &#123; String str = "aaa"; list.add(str);&#125; 不要在循环中使用try…catch…，应该把其放在最外层； 使用带缓冲的输入输出流进行IO操作； 尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销； 尽量在合适的场合使用单例； 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： （1）控制资源的使用，通过线程同步来控制资源的并发访问 （2）控制实例的产生，以达到节约资源的目的 （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据 + &quot;&quot;最慢； 使用AS自带的Lint来优化代码结构（什么，你不会？右键module、目录或者文件，选择Analyze → Inspect Code）； 最后不要忘了内存泄漏的检测； 最后啰嗦几句： 好的命名规则能够提高代码质量，使得新人加入项目的时候降低理解代码的难度； 规矩终究是死的，适合团队的才是最好的； 命名规范需要团队一起齐心协力来维护执行，在团队生活里，谁都不可能独善其身； 一开始可能会有些不习惯，持之以恒，总会成功的。 附录UI控件缩写表 名称 缩写 TextView tv EditText et ImageButton ib Button btn ImageView iv ListView lv GridView gv ProgressBar pb SeekBar sb RadioButtion rb CheckBox cb ScrollView sv LinearLayout ll FrameLayout fl RelativeLayout rl RecyclerView rv WebView wv VideoView vv Spinner spn ToggleButton tb 常见的英文单词缩写表 名称 缩写 icon ic （主要用在app的图标） color cl（主要用于颜色值） average avg background bg（主要用于布局和子布局的背景） selector sel主要用于某一view多种状态，不仅包括Listview中的selector，还包括按钮的selector） buffer buf control ctrl default def delete del document doc error err escape esc increment inc infomation info initial init image img Internationalization I18N length len library lib message msg password pwd position pos server srv string str temp tmp window wnd(win) 程序中使用单词缩写原则：不要用缩写，除非该缩写是约定俗成的。 参考Android包命名规范 Android 开发最佳实践 Android 编码规范 阿里巴巴Java开发手册 Google Java编程风格指南 小细节，大用途，35 个 Java 代码性能优化总结！ 版本日志 17/03/06: 发布初版 ； 17/03/07: 修订目录排版，完善某些细节； 17/03/08: 规范排版，修复typor及新增一些规范； 17/03/13: 新增其他注释； 17/03/14: 包名划分为按功能划分； ——powered by Blankj(蔡梦杰)]]></content>
      <categories>
        <category>安卓开发规范</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
        <tag>开发约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最详细的android Proguard 混淆教程]]></title>
    <url>%2F2017%2F04%2F21%2F%E6%9C%80%E8%AF%A6%E7%BB%86%E7%9A%84android-Proguard-%E6%B7%B7%E6%B7%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ProGuard是一个压缩、优化和混淆Java字节码文件的免费的工具，它可以删除无用的类、字段、方法和属性。可以删除没用的注释，最大限度地优化字节码文件。它还可以使用简短的无意义的名称来重命名已经存在的类、字段、方法和属性。常常用于Android开发用于混淆最终的项目，增加项目被反编译的难度。 ProGuard工作原理ProGuar由shrink、optimize、obfuscate和preveirfy四个步骤组成，每个步骤都是可选的，我们可以通过配置脚本来决定执行其中的哪几个步骤。 压缩(Shrink)：检测并移除代码中无用的类、字段、方法和特性（Attribute）。 优化(Optimize)：对字节码进行优化，移除无用的指令。 混淆(Obfuscate)：使用a，b，c，d这样简短而无意义的名称，对类、字段和方法进行重命名。 预检(Preveirfy)：在Java平台上对处理后的代码进行预检，确保加载的class文件是可执行的。 那么ProGuard是如何工作的呢？在这里我们引入一个概念EntryPoint。EntryPoint可以理解为一种标志，它是在ProGuard过程中不会被处理的类或者方法，在压缩的过程,ProGuard会从上述的EntryPoint中开始遍搜索出哪些类和类的成员在使用（被标记为EntryPoint的类和方法有些是在使用的而且这些是我们在混淆文件中配置不希望被混淆的类和方法，有些是没有使用的）。对于那些没有被使用的类和成员，就会在压缩阶段被丢弃。然后在接下来的优化步骤中，那些非EntryPoint的类，方法都会被设置为private，static或者final，而且不使用的参数都会被移除。接着在混淆的步骤中，ProGuard会对非EntryPoint的类和方法进行重命名。最后就会对代码进行预检测，以便保证稳定性。 Entry points官方介绍 ###Entry points In order to determine which code has to be preserved and which code can be discarded or obfuscated, you have to specify one or more entry points to your code. These entry points are typically classes with main methods, applets, midlets, activities, etc. In the shrinking step, ProGuard starts from these seeds and recursively determines which classes and class members are used. All other classes and class members are discarded.In the optimization step, ProGuard further optimizes the code. Among other optimizations, classes and methods that are not entry points can be made private, static, or final, unused parameters can be removed, and some methods may be inlined.In the obfuscation step, ProGuard renames classes and class members that are not entry points. In this entire process, keeping the entry points ensures that they can still be accessed by their original names.The preverification step is the only step that doesn’t have to know the entry points. 使用-keep可以使指定的类和类成员成为Entry Point, 其实就是扫描开始的地方, 即使没有其他人直接引用这个类或者类成员, 也保留它. Android 混淆配置原则: 反射用到的类不混淆 JNI方法不混淆 AndroidMainfest中的类不混淆，四大组件和Application的子类和Framework层下所有的类默认不会进行混淆 Parcelable的子类和Creator静态成员变量不混淆，否则会产生android.os.BadParcelableException异常 继承了Serializable接口的类不混淆 使用GSON、fastjson等框架时，所写的JSON对象类不混淆，否则无法将JSON解析成对应的对象 使用第三方开源库或者引用其他第三方的SDK包时，需要在混淆文件中加入对应的混淆规则 有用到WEBView的JS调用也需要保证写的接口方法不混淆 在AndroidManifest中配置的类，比如四大组件 Layout文件引用到的自定义View 引入的第三方库（一般）。这里推荐两个开源项目，里面收集了一些第三方库的混淆规则 android-proguard-snippets android-proguard-cn 删除Syst.out 和Log.d打印输出代码 语法详细说明参见官方文档 保留 -keep {Modifier} {class_specification} 保护指定的类文件和类的成员 -keepclassmembers {modifier} {class_specification} 保护指定类的成员，如果此类受到保护他们会保护的更好 -keepclasseswithmembers {class_specification} 保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 -keepnames {class_specification} 保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） -keepclassmembernames {class_specification} 保护指定的类的成员的名称（如果他们不会压缩步骤中删除） -keepclasseswithmembernames {class_specification} 保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） -printseeds {filename} 列出类和类的成员-keep选项的清单，标准输出到给定的文件 压缩 -dontshrink 不压缩输入的类文件 -printusage {filename} -whyareyoukeeping {class_specification} 优化 -dontoptimize 不优化输入的类文件 -assumenosideeffects {class_specification} 优化时假设指定的方法，没有任何副作用 -allowaccessmodification 优化时允许访问并修改有修饰符的类和类的成员 混淆 -dontobfuscate 不混淆输入的类文件 -obfuscationdictionary {filename} 使用给定文件中的关键字作为要混淆方法的名称 -overloadaggressively 混淆时应用侵入式重载 -useuniqueclassmembernames 确定统一的混淆类的成员名称来增加混淆 -flattenpackagehierarchy {package_name} 重新包装所有重命名的包并放在给定的单一包中 -repackageclass {package_name} 重新包装所有重命名的类文件中放在给定的单一包中 -dontusemixedcaseclassnames 混淆时不会产生形形色色的类名 -keepattributes {attribute_name,…} 保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, * Deprecated, Synthetic, Signature, and InnerClasses. -renamesourcefileattribute {string} 设置源文件中给定的字符串常量 通配符 通配符 规则 ？ 匹配单个字符 * 匹配类名中的任何部分，但不包含额外的包名 ** 匹配类名中的任何部分，并且可以包含额外的包名 % 匹配任何基础类型的类型名 * 匹配任意类型名 ,包含基础类型/非基础类型 … 匹配任意数量、任意类型的参数 匹配任何构造器 匹配任何字段名 匹配任何方法 *(当用在类内部时) 匹配任何字段和方法 $ 指内部类 公共配置选项这是配置项，基本不需要动，全部加上 # 忽略警告，避免打包时某些警告出现 # #-ignorewarnings #不要忽略警告，风险太大 # 指定代码的压缩级别 -optimizationpasses 5 # 不使用大小写混合，混淆后的类名为小写 -dontusemixedcaseclassnames #指定不去忽略非公共的库的类 -dontskipnonpubliclibraryclasses #指定不去忽略非公共的库的类的成 -dontskipnonpubliclibraryclassmembers # 不做预校验，preverify是proguard的4个步骤之一 # Android不需要preverify，去掉这一步可加快混淆速度 -dontpreverify # 有了verbose这句话，混淆后就会生成映射文件 # 包含有类名-&gt;混淆后类名的映射关系 # 然后使用printmapping指定映射文件的名称 -verbose -printmapping proguardMapping.txt # 指定混淆时采用的算法，后面的参数是一个过滤器 # 这个过滤器是谷歌推荐的算法，一般不改变 #-optimizations !code/simplification/cast,!field/*,!class/merging/* #避免混淆注解和内部类，对json解析重要 -keepattributes *Annotation*,InnerClasses # 避免混淆泛型，这在JSON实体映射时非常重要，比如fastJson -keepattributes Signature #报错后方便恢复堆栈信息 -keepattributes SourceFile,LineNumberTable -keepattributes EnclosingMethod # 指定混淆时采用的算法，后面的参数是一个过滤器 # 这个过滤器是谷歌推荐的算法，一般不改变 -optimizations !code/simplification/arithmetic,!field/*,!class/merging/* 需要保留的东西这个不需要动的，要全部添加上 # 保留所有的本地native方法不被混淆 -keepclasseswithmembernames class * { native &lt;methods&gt;; } # 保留了继承自Activity、Application这些类的子类 # 因为这些子类，都有可能被外部调用 # 比如说，第一行就保证了所有Activity的子类不要被混淆 -keep class android.os.**{*;} -keep public class * extends android.app.Activity -keep public class * extends android.support.v4.** -keep public class * extends android.support.v7.** -keep public class * extends android.app.Fragment -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.view.View -keep public class com.android.vending.licensing.ILicensingService -keep class android.app.Notification { *;} # 如果有引用android-support-v4.jar包，可以添加下面这行 #-keep public class com.xxxx.app.ui.fragment.** {*;} # 保留在Activity中的方法参数是view的方法， # 从而我们在layout里面编写onClick就不会被影响 -keepclassmembers class * extends android.app.Activity { public void *(android.view.View); } # 枚举类不能被混淆 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } # 保留自定义控件（继承自View）不被混淆 -keep public class * extends android.view.View { *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); } #Design包下的Beheviar -keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); } # 保留Parcelable序列化的类不被混淆 -keep class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator *; } #需要序列化和反序列化的类不能被混淆（注：Java反射用到的类也不能被混淆） -keepnames class * implements java.io.Serializable # 保留Serializable序列化的类不被混淆 -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } # 对于R（资源）下的所有类及其方法，都不能被混淆 -keep class **.R$* { *; } # 对于带有回调函数onXXEvent的，不能被混淆 -keepclassmembers class * { void *(**On*Event); } #webView -keepattributes *JavascriptInterface* -keepclassmembers class * extends android.webkit.WebViewClient { public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String); } -keepclassmembers class * extends android.webkit.WebViewClient { public void *(android.webkit.WebView, java.lang.String); } -keep public class android.net.http.SslError #v4 -dontwarn android.support.v4.** -dontwarn android.app.Notification -dontwarn android.net.SSLCertificateSocketFactory -dontwarn android.util.FloatMath -dontwarn android.test.** -dontwarn org.junit.** -dontwarn android.utils.imagecache.* -dontwarn android.utils.* -dontwarn android.view.* #----------------------------------- -assumenosideeffects class android.util.Log { public static boolean isLoggable(java.lang.String, int); public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...); } 保留model中的实体类和成员不被混淆将下面的包名（com.android4package.model）替换你自己的 -keep public class com.android4package.model.**{ *; } 反射的处理在程序中使用SomeClass.class.method这样的静态方法，在ProGuard中是在压缩过程中被保留的，那么对于Class.forName(“SomeClass”)呢，SomeClass不会被压缩过程中移除，它会检查程序中使用的Class.forName方法，对参数SomeClass法外开恩，不会被移除。但是在混淆过程中，无论是Class.forName(“SomeClass”)，还是SomeClass.class，都不能蒙混过关，SomeClass这个类名称会被混淆，因此，我们要在ProGuard文件中保留这个类名称。 Class.forName(“SomeClass”) SomeClass.class SomeClass.class.getField(“someField”) SomeClass.class.getDeclaredField(“someField”) SomeClass.class.getMethod(“someMethod”, new Class[] {}) SomeClass.class.getMethod(“someMethod”, new Class[] { A.class }) SomeClass.class.getMethod(“someMethod”, new Class[] { A.class, B.class }) SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] {}) SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class }) SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class, B.class }) AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, “someField”) AtomicLongFieldUpdater.newUpdater(SomeClass.class, “someField”) AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, “someField”)在混淆的时候，要在项目中搜索一下上述方法，将相应的类或者方法的名称进行保留而不被混淆。 第三方包的处理第三方包可以去库的官网查看混淆规则,没什么难点，复制粘贴就ok。这里推荐两个开源项目，里面收集了一些第三方库的混淆规则 android-proguard-snippets android-proguard-cn #---------------------------------2.第三方包------------------------------- #eventBus -keepattributes *Annotation* -keepclassmembers class ** { @org.greenrobot.eventbus.Subscribe &lt;methods&gt;; } -keep enum org.greenrobot.eventbus.ThreadMode { *; } -keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent { &lt;init&gt;(java.lang.Throwable); } #glide -keep public class * implements com.bumptech.glide.module.GlideModule -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** { **[] $VALUES; public *; } #------------------------------------------------------------------------- Android Studio中使用方法按照上面的语法规则编写proguard-rules.pro后，需要在build.gradle中配置，需要混淆的时候，设置minifyEnabled为true即可 buildTypes { debug { minifyEnabled true //proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; proguardFiles &apos;proguard-rules.pro&apos; } release { signingConfig signingConfigs.release minifyEnabled true proguardFiles &apos;proguard-rules.pro&apos; } } android混淆之后文件优化结果文件会输出到/build/outputs/mapping/release/目录. dump.txt : 描述APK中所有类文件的内部结构(internal structure) mapping.txt : 提供混淆前后类(class)名, 方法(method)名和成员变量(field)名的对应关系。表示混淆前后代码的对照表，这个文件非常重要。如果你的代码混淆后会产生bug的话，log提示中是混淆后的代码，希望定位到源代码的话就可以根据mapping.txt反推。 seeds.txt : 列出没有被混淆的类和成员(classes and members) usage.txt : 列出从APK中移除的代码(code) 如何恢复混淆之后堆栈信息?使用方法如下： GUI 打开/tools/proguard/bin/proguardgui.bat 选择左边栏的ReTrace选项 添加你的mapping文件和混淆过的堆栈信息 点击ReTrace! 命令行1.需要你的ProGuard的mapping文件和你想要还原的堆栈信息（如stacktrace.txt）2.最简单的方法就是将这些文件拷贝到/tools/proguard/bin/目录3.运行以下命令//Windowsretrace.bat -verbose mapping.txt stacktrace.txt &gt; out.txt //Mac/Linuxretrace.sh -verbose mapping.txt stacktrace.txt &gt; out.txt 所以我们每次打包版本都需要保存最新的mapping.txt文件。如果要使用到第三方的crash统计平台，比如bugly，还需要我们上传APP版本对应的mapping.txt.每次都要保存最新的mapping文件，那不就很麻烦？放心，gradle会帮到你，只需要在bulid.gradle加入下面的一句。每次我们编译的时候，都会自动帮你保存mapping文件到本地的。 android { applicationVariants.all { variant -&gt; variant.outputs.each { output -&gt; if (variant.getBuildType().isMinifyEnabled()) { variant.assemble.doLast{ copy { from variant.mappingFile into &quot;${projectDir}/mappings&quot; rename { String fileName -&gt; &quot;mapping-${variant.name}.txt&quot; } } } } } ...... } } 混淆成中文原始的混淆功能是把类名方法名混淆成a、b、c、d、e,改造后也可以混淆成中文，参考这篇文章和github上的这个库https://github.com/heruoxin/proguard-elder-dictionary 其他 建议开发和测试阶段都要开启混淆，如果嫌开发阶段恢复堆栈信息麻烦，必须保证测试阶段是开启的，可以尽早发现问题。 打包生成的mapping文件一定要保存好，bug收集网站如腾讯bugly和友盟bug统计还原堆栈的时候都需要对应版本的mapping文件。 参考 官方文档https://www.guardsquare.com/en/proguard/manual/usage 官方exampleshttps://www.guardsquare.com/en/proguard/manual/examples#androidapplication http://www.jianshu.com/p/f3455ecaa56e https://segmentfault.com/a/1190000004461614 http://www.cnblogs.com/cr330326/p/5534915.html 混淆成中文http://blog.csdn.net/jiangwei0910410003/article/details/61618945 Proguard Elder Dictionary,使用中文作为字典可以略微提升二次打包的难度https://github.com/heruoxin/proguard-elder-dictionary]]></content>
      <categories>
        <category>Android Proguard</category>
      </categories>
      <tags>
        <tag>android混淆</tag>
        <tag>Proguard</tag>
        <tag>android Proguard</tag>
        <tag>恢复堆栈</tag>
        <tag>Unknown Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis-CI自动更新Hexo博客到Github Page]]></title>
    <url>%2F2017%2F04%2F20%2FTravis-CI%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0Github%20Page%2F</url>
    <content type="text"><![CDATA[Travis-CI自动更新Hexo博客到Github Page前言如过你是用Hexo和github page来构建自己的独立博客，你一定被多端同步困扰过，如果你的公司安装了Hexo构建环境，但是家里电脑却没有，如果想在家更新博客就变得麻烦了，你需要把你公司博客源文件拷贝到你家里电脑里，然后安装Node、Hexo、Git，生成Ssh等等。有人就考虑用dropbox等云盘或者git仓库进行同步，但是总体流程不够顺畅。有没有更好的方式处理呢？答案是肯定的的。如何操作？ githubPage仓库下建立另一个分支，命名blog-source，用来保存我们的博客源代码 用持续集成工具关联github仓库，我的是https://github.com/ytjojo/ytjojo.github.io.git，并监听blog-source分支代码改动。 将博客源代码push到仓库的blog-source分支， 持续集成工具监听到push，运行脚本 持续集成工具将生成public文件夹下的博客静态文件push到仓库的主分支master上。 打开https://ytjojo.github.io/看到改动。 Travis CI Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，同时他是在在线的服务，不像jenkins需要你本地打架服务器，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。对于做开源项目或者github的使用者，如果你的项目还没有加入Travis CI构建队列，那么我真的想对你说out了。 登录用github账号登录Tavis CI 登录后就会看到 点击加号 找到你的github仓库，将开关打开 开启后需要配置下，点击红框的那个菜单按钮 就会出现这样的下拉菜单，我们选择设置，来到这个界面，我们按照如下勾选 Build only if .travis.yml is present：是只有在.travis.yml文件中配置的分支改变了才构建Build pushes：当推送完这个分支后开始构建 到这一步，Tavis 会监听到blog-source 分支下pushes，并进行构建。但是如何构建，还有构建完成后如何将hexo生成要public文件夹内容推送到仓库 master分支上这些问题还没解决。 配置githhub的Access Token打开github首页，右上角 打开下拉菜单 Setting，进入之后点击Personal access tokens，点击右上角的Generate new token按钮， 除了delet repo全部勾选上 生成完成后拷贝下来，在Trav Ci页面，添加环境变量GH_TOKEN，value就是复制的github access token 初始化blog—source分支本地磁盘新建文件夹，将远程仓库blog-source分支拉下来，没有就新建git命令 git init # 添加自己的项目 git remote add origin git@github.com:ytjojo/ytjojo.github.io.git # 新建并切换分支 git checkout --orphan blog-source git add -A git commit -m &quot;Travis CI&quot; git push 将hexo源码复制到这个git仓库目录下必须的文件如下 . ├── _config.yml* ├── db.json* ├── node_modules ├── package.json* ├── scaffolds* ├── source* │ ├── CNAME* │ ├── _posts │ ├── about │ ├── categories │ ├── img │ ├── media │ └── tags └── themes 同时在当前目录下新建.travis.yml language: node_js node_js: stable # S: Build Lifecycle install: - npm install - yarn #before_script: #- npm install -g gulp # 缓存，可以节省集成的时间，这里我用了yarn，如果不用可以删除 cache: apt: true yarn: true directories: - node_modules # tarvis生命周期执行顺序详见官网文档 before_install: - git config --global user.name &quot;ytjojo&quot; #替换自己的 - git config --global user.email &quot;ytjojo@163.com&quot; #替换自己的 # 由于使用了yarn，所以需要下载，如不用yarn这两行可以删除 - curl -o- -L https://yarnpkg.com/install.sh | bash - export PATH=$HOME/.yarn/bin:$PATH - npm install -g hexo - git clone https://github.com/raytaylorlin/hexo-theme-raytaylorism.git themes/raytaylorism #这个要替换你自己的主题 script: - hexo clean - hexo g after_success: - cd ./public - git init - git add --all . - git commit -m &quot;Update docs&quot; - git push --quiet --force https://$GH_TOKEN@$GH_REF #注意没有双引号，我被坑过 master # E: Build LifeCycle branches: only: - blog-source env: global: - GH_REF: github.com/ytjojo/ytjojo.github.io.git #替换自己的 提交blog-source分支分支文件结构如图 最后将本地blog-source 分支提交到远程，Travis 就会自动构建然后push到你github page master分支上 参考文章 https://github.com/ytjojo/ytjojo.github.io.git http://kchen.cc/2016/11/12/hexo-instructions/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Travis-CI</tag>
        <tag>自动更新Hexo</tag>
        <tag>多端同步</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo和GitHub Pages建立个人博客]]></title>
    <url>%2F2017%2F04%2F18%2Fhexo%E5%92%8Cgithubpage%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[#Hexo和GitHub Pages建立个人博客 作为一个程序员，一直想写点技术文章，一来记录下自己的工作学习心得体会，二是遇到棘手问题或者深层理论可以理清楚思路头绪，记录下来方便以后查找，三是锻炼自己表达和整理能力，四分享给同行业需要的人，帮别人解决共同问题，如果内容比较精髓，可以增加自己的影响力。总之好处多多。但是去哪写是个问题，大部分人选择简书，CSDN，cnblogs，LOFTER，在这些平台写博客方便，但是自定义功能太差，界面千篇一律不够极客，所以我选择了自建。自建的方式有WordPress、Jekyll和Octopress，但是配置什么的比较麻烦，最后选择了HEXO 简介hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。官方中文文档在这里 环境准备安装Node.js到Node.js的官网下载对应平台的最新版本，有两个可选项，Recommended for most User 和 Latest Features,我下载的是Recommended for most User V6.10.2LTS 版本。一路安装，自定义安装的话注意配置环境变量。配置教程看这里 安装Hexo打开命令行，键入命令 1npm install -g hexo 安装git去git官方网站下载页选择对应平台下载，安装教程在这设置下环境变量。 Github注册和GitHubPage建立 注册github账号，已有忽略。 建立与你账户名对应的仓库，仓库名必须是[your_name.github.io],一个账号下只能建一个。 生成SSH Keys 首先设置你的用户名密码： git config --global user.email &quot;你的邮箱&quot; git config --global user.name &quot;github用户名&quot; cd ~/.ssh #检查本机的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git 生成ssh key，替换你的邮件地址 ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; 提示 Generating public/private rsa key pair. Enter file in which to save the key (/Users/Administrator/.ssh/id_rsa):#&lt;回车就好&gt; 然后系统会要你输入密码： Enter passphrase (empty for no passphrase):&lt;输入加密串&gt; Enter same passphrase again:&lt;再次输入加密串&gt; 注意，你可能疑惑输入密码命令行窗口却不显示，不要惊慌，只要正常输入就好了。 添加SSH key 到github用记事本打开本地C:\Documents and Settings\Administrator.ssh\id_rsa.pub文件，完全复制文本内容 登陆github系统。点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了 测试github ssh key键入命令 ssh -vT git@github.com 如果看到 The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 输入yes就好，最后如果看到 Hi 【你的用户名】! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 就表示成功了 搭建Hexo工作空间在电脑上建立一个处理博客的文件夹如E:\blog_github\hexo，鼠标右键Git Bash Here 打开命令行，输入： hexo init npm install #安装所需要的依赖包 执行完成后看到目录结构 . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 结构说明： _config.yml：可以在这里配置需要的配置。 package.json：应用程序数据。EJS, Stylus 和 Markdown渲染器会自动安装。如果想要卸载他们，也是可以的。 scaffolds：当你创建一个新文章时，用到的模板文件。 themes：主题。 您可以在 _config.yml 中修改大部份的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 网站存放在子目录如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 提示如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 相对地址默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 现在已经搭建本地Hexo博客了，执行以下命令，然后在浏览器输入http://localhost:4000 hexo g #生成博客依赖的html css js文件 hexo s #本地提供博客服务 就会看到如下界面 更改网站描述信息打开你hexo工作目录如E:\blog_github\hexo，找到_config.yml文件打开，配置以下参数 title: 张三的博客 subtitle: 学习笔记 description: That&apos;s all, thank you！ author: 张三 language: zh-CN timezone: Asia/Shanghai 注意冒号之后有一个空格的，不然解析报错 关联github仓库打开你hexo工作目录如E:\blog_github\hexo，找到_config.yml文件打开 deploy: type: git repo: git@github.com:ytjojo/ytjojo.github.io.git branch: master 将Hexo系统绑定到你的github page网址打开你hexo工作目录如E:\blog_github\hexo，找到_config.yml文件打开，找到# URl这一项，更改url: 和root: 内容，如 # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: https://github.com/ytjojo/ytjojo.github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults: 由于我Hexo是直接初始化在blog根目录文件夹下的，因此我的url和root没有改动，如果是初始化在子目录下的(如：blog中的hexo目录)就需要改为 url: https://github.com/ytjojo/ytjojo.github.io/hexo root: /hexo/ 配置完成，清除生成静态文件 hexo clean 重新生成静态文件 hexo g #hexo generate的简化版 部署到your_name.github.io. hexo d #hexo deploy的简化版，部署到github远程仓库 如果发布时候出现错误 ERROR Deployer not found: git 执行 npm install hexo-deployer-git --save 出现 hexo-site@0.0.0 E:\blog_github\hexo `-- hexo-deployer-git@0.2.0 表示正常安装，默认是0.2.0版本，默认也可以指定高版本的， npm install hexo-deployer-git@0.4.0 --save 直到命令行出现 Branch master set up to track remote branch master from git@github.com:ytjojo/ytjojo.github.io.git. To github.com:ytjojo/ytjojo.github.io.git ad4d091..817debc HEAD -&gt; master INFO Deploy done: git 打开你的主页,https://ytjojo.github.io/，就会看到你的博客了 添加文章 如果已经有写好的markdown文件打开文件，头部加入下面描述。已经有就忽略 title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改 categories: example #分类 tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格 description: 附加一段文章摘要，字数最好在140字以内。复制到source_posts文件夹下面 如果是新建文章 hexo new [layout] “postName” #新建文章 其中layout是可选参数，hexo提供了3种默认的布局， post 、 page 和 draft ，路径分别为： source/_posts 、 source 、 source/_draft 。如果你将在文章前置申明中，将layout设置为false，那么这篇文章将不会有任何的布局。如果不写layout类型，默认到source/_post文件夹，如果想放入草稿文件夹，输入 hexo new draft &quot;我新建的草稿文章&quot; 找到source/_draft文件夹对应的文件打开，发现少了categories，date等，可以手动添加，也可以配置下，下次执行 hexo new &quot;新的文章&quot; 时候默认就会有这些信息配置方法：在你的hexo工作空间打开scaffolds\post.md或者scaffolds\draft.md,输入 --- title: {{ title }} date: {{ date }} categories: tags: description: --- 新建文章之后，就可以用自己喜欢的markdown 编辑器写文章了 注意：source/_posts是网站中显示的文章source/_draft是草稿文件夹，有些主题默认不显示的，如果你在草稿里已经完成了文章，请将文章复制到source/_posts文件夹下 将新建的文章发布到博客里hexo clean hexo g hexo d 过一会儿打开你的博客网址https://ytjojo.github.io/,就会看到你写的博客了 fancybox 可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片： layout: photo title: 我的阅历 date: 2085-01-16 07:33:44 tags: [hexo] photos: - http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg - http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg 如果不想每次添加，打开您的scaffolds\photo.md，没有的话新建一个。 layout: { { layout } } title: { { title } } date: { { date } } tags: photos: - --- 然后每次可以执行带layout的new命令生成照片文章： hexo new photo &quot;photoPostName&quot; #新建照片文章 文章摘要在需要显示摘要的地方添加如下代码即可： 以上是摘要 &lt;!--more--&gt; 以下是余下全文 用&lt;!--more--&gt;分割摘要和正文, more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。 参考文章 http://ibruce.info/2013/11/22/hexo-your-blog/ http://www.jianshu.com/p/05289a4bc8b2 http://www.jianshu.com/p/a4b74cc9ff28 http://blog.csdn.net/u014595668/article/details/51854259 hexo官方中文文档https://hexo.io/zh-cn/docs/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>Hexo</tag>
        <tag>git配置</tag>
        <tag>ssh</tag>
        <tag>github page</tag>
        <tag>建立个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习笔记]]></title>
    <url>%2F2017%2F04%2F15%2Fmarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Markdown学习笔记[toc] 导语markdown是一种轻量级的标记语言，宜读宜写，常被用了写文章，记日记，总结经验，也被程序员用了写技术文档，技术博客。markdown的语法比较简单，常用的也就不超过10个，学习成本也比较低，一旦熟悉这种语法规则，有一劳永逸的效果，对以后的工作学习都有很好的帮助。简书、github、Tumblr等平台都原生支持markdown语法，学习markdown更有助于写出简洁美观宜与阅读的文章。 Markdown 官方文档 创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 Markdown工具推荐Mac Os X MOU被很多人推荐 Ulysses一款由国外开发商 The Soulmen 制作的 Markdown 编辑器。与其它同类应用相比，Ulysses 最大的不同在于，它能根据内置的文件管理器，以及与 iCloud 云服务器的实时同步方案，达到最快捷的文章整理效率。 Mweb界面简洁高效、功能强大全面支持 Github Flavored Markdown 语法如 TOC、Table、Fenced code block、LaTex、Task lists、Footnote 等。内置图床功能。 Windows平台上 MarkdownEditorMetro风格的markdown编辑器，号称功能最全，一个亮点是与七牛存储集成，可以直接将本地图片上传到服务器，将图片的URL地址嵌入到编辑器 MarkdownPad一款全功能的编辑器，被很多人称赞为windows 平台最好用的markdown编辑器 MarkPad开源的 Markdown 编辑器,与 Window 8 风格和谐友好的界面，可以直接在你的博客或者 GitHub 中打开、保存文档，直接将图片粘贴到 Markdown 文档中。 web端 简书,简书是一个将写作与阅读整合在一起的网络产品。集合文字的书写、编集、发布功能于一体的在线写作编辑工具。 StackEdit好用的网页版编辑器 开源，免费，搭建在github page上，源码寄存在GitHub。整合Dropbox和Google Drive，自动同步（如果能够指定文件夹自动同步当然是最好的）支持一键发布到Google Blog，Tumblr等。可左右或者上下分栏，一边显示Markdown语言一边显示效果可以单击左右栏分界线切换至纯写作模式，同样可以收缩顶部工具栏。在网页顶部工具栏支持加粗、倾斜、超链接、撤消和还原 等等（注意：与Word处理方式有稍许不同）。不论在左栏还是右栏滚动页面另一侧也会同步。支持Markdown Extra 以GIst发布后支持分享（可以在线使用StackEdit阅读）多种保存格式详细的说明文档界面优美. Markable.in，支持实时预览，自动保存，保存到Dropbox，发布到Tumblr等。 跨平台 Cmd Markdown 作业部落出品，也是一款不错的工具和博客平台兼顾的产品。全平台且提供web版 Haroopad是一款覆盖三大主流桌面系统的编辑器，支持 Windows、Mac OS X 和 Linux。 主题样式丰富，语法标亮支持 54 种编程语言。最新版支持流程图和幻灯片 小书匠编辑器 全平台覆盖并且有web版 Typora 有Windows 和Linux版本 文库集成类 GitBook: 集成GitHub Madoko: 集成GitHub, DropBox, OneDrive 马克飞象: 集成印象笔记GitBook的火热程度如同GitHub，我所看到的很多软件帮助文档、技术教程，都已经在GibBook上发布。GitBook于2014年创办，已发布35500本书籍。 图床Markdown作为纯文本格式，自然不能粘贴图像文件，只能嵌入图像的地址（URL或者本地地址）。所以插入图片需要预先将图片存储在网络。 在chrome搜图床就会出现这三个，都挺好用的。另外一个图床墙裂推荐七牛，七牛是云服务提供商，注册就送10G云存储如何使用看这篇文章http://www.jianshu.com/p/5f0d5451ca01配合MPic，一款支持拖曳、复制、截图上传的七牛图床神器,用起来爽爆了。 截屏工具windows平台Faststone Capture 体积小巧、功能强大。不但具有常规截图等功能，更有从扫描器获取图像，和将图像转换为 PDF 文档等功能,该软件拥有不规则抓图、滚动抓图、活动窗口抓图、图片简单处理、屏幕录制等很多很多实用的功能。 Mac OS X平台 Snip Snip是一款腾讯推出的一款截图工具，是Mac平台的截屏应用，支持自动识别窗口、图标标记再次编辑、关联QQ邮箱截屏、滚动截屏、邮件分享截图、支持Retina显示屏等。 语法1. 标题行首用1-6个#开头表示不同级别的标题，注意#号和文字之间有个空格，在有些编辑器或者网站上会自动生成文章目录 2. 引用行首使用 &gt; 加上一个空格表示引用一个段落，可嵌套嵌套写法 ： &gt; &gt; + 空格 + 内容 This is the first level of quoting. This is nested blockquote. Back to the first level. 3. 分割线在一行连续三个或者三个以上_或者* ___ *** 途中分割线不是很明显。 4. 代码区域代码区域内的文字不会被处理，按照原样输出。每一行前边加入4个空格或者一个tab可以标记一个代码段落： int main(){ return 0 } 效果如下 还可以使用 `这是代码块` 来标记行内代码 如：在activity的初始化代码一般是` protected void onCreate(Bundle savedInstanceState){super.onCreate(savedInstanceState);}` 效果如下 也可以用三个`表示代码块,一般github readme文档常用此方法 12var a = "hello world";var b = "good luck"; 5. 强调*斜体* **粗体** _斜体_ __粗体__ 6. 链接Markdown有两种链接方式：Inline以及Reference 文字链接 Inline: 谷歌 Reference: [谷歌][google_url] [google_url]:https://www.google.com 图片链接 ![](https://www.baidu.com/img/bd_logo1.png) ![][baidu_logo] [baidu_logo]:https://www.baidu.com/img/bd_logo1.png 注意！第二种叹号后第一个[]容易漏掉，一定不要忘记哦。当图片url地址含有(或)时的处理 ![](http://latex.codecogs.com/gif.latex?%5Cprod(n_%7Bi%7D+100)) ![][latex_img] [latex_img]:http://latex.codecogs.com/gif.latex?%5Cprod(n_%7Bi%7D+100) &lt;img src=&quot;http://latex.codecogs.com/gif.latex?\prod(n_{i_1})+10000&quot;&gt; 自动链接 使用尖括号&lt;&gt;包含住一段地址或者邮箱 &lt;http://www.baidu.com&gt; 图片大小控制 固定图片显示大小： src123456```百分比控制大小```&lt;img src=&quot;http://img.blog.csdn.net/20151129213701642&quot; width=&quot;50%&quot; alt=&quot;图片名称&quot; align=center /&gt; 给图片加脚注1234&lt;center&gt;&lt;img src="http://img.blog.csdn.net/20151129213701642" width="25%" alt="图片名称" align=center /&gt;Figure 1. Lena&lt;/center&gt; Figure 1. Lena 增大脚注12345&lt;center&gt;&lt;img src="http://img.blog.csdn.net/20151129213701642" width="25%" height="25%" /&gt;$ $Figure 1. Lena&lt;/center&gt; $ $Figure 1. Lena 7. 转义字符123456789101112131415\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号&amp;gt; &gt; &amp;amp; &amp;&amp;nbsp； 空格（non-breaking space） 8. 列表 无序列表 一个*或者+或者- 加上一个空格 无序列表 无序列表 无序列表 有序列表 使用数字接着一个英文句点再加一个空格,数字可以任意值 1. 第一项 1. 第二项 1. 第三项 嵌套列表 在每个嵌套列表行首比上一级多加三个空格 第一项 第二项 第一项 第二项 第三项 第三项 第四项 第一项 第二项 第三项 12345678910* 第一项* 第二项 * 第一项 * 第二项 * 第三项* 第三项* 第四项 1. 第一项 2. 第二项 3. 第三项 9. 段落和换行单个回车视为空格.连续回车才能分段 两种方式 输入&lt;br/&gt; #有写编辑器不支持。。 两个空格加回车键 10. 页内跳转，也称为锚 github支持的一种方式， [描述](#标题)中括号是显示的文字，圆括号（）内部中#号跟着在此文档定义的次级标题#### 9. 段落和换行 gitlab和markdownpad2支持的一种，要跳转目标位置添加&lt;a name=&quot;md-anchor&quot; id=&quot;md-anchor&quot;&gt;&lt;/a&gt; 跳转至[文内链接](#md-anchor) 跳转至 文内链接 。中括号内为显示文字，（）中#号后面跟随对应&lt;a标签对应name 一下是扩展语法 10. 任务列表未做任务- + 空格 + [ ]已做任务- + 空格 + [x] - [ ] 任务一 给女朋友买口红 - [x] 任务二 陪女朋友吃饭 11. 表格格式第一格表头 | 第二格表头 --------- | ------------- 内容单元格 第一列第一格 | 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 12. 删除线加删除线像这样用： ~~删除这些~~ 加删除线像这样用： 删除这些 13. 顺序图或流程图123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 14. MathJax关于MathJax与LaTex 可参考该文章 块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ \\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} = 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\ldots} } } } \\] 行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ 15. 脚注(Footnote)第一[^1x] [^1x]:脚注的用法 百度地址[^百度地址] [^百度地址]:www.baidu.com 在文档的末尾自动生成如下图所示脚注 16. TOC如果想点击文章中某一小标题自动滚动到标题位置，如何做呢，很简单。 1[toc] 17. emoji表情表情一：:+1:,表情二：:o: 表情一：:+1:,表情二：:o: 下划线下划线 效果 &lt;u&gt;下划线&lt;/u&gt; 效果 上标、下标 Water: H2O E = mc2 - Water: H&lt;sub&gt;2&lt;/sub&gt;O - E = mc&lt;sup&gt;2&lt;/sup&gt; 参考文章: http://www.jianshu.com/p/4Q3aay http://www.cnblogs.com/gibbonnet/p/5373703.html https://www.zhihu.com/question/19637157 http://zh.mweb.im/markdown-syntax-guide-suggest-version-zh.html#toc_24 http://www.williamlong.info/archives/4319.html http://www.jianshu.com/p/1e402922ee32/ Markdown 语法说明 (简体中文版)http://wowubuntu.com/markdown/#p http://blog.csdn.net/yhl_leo/article/details/50099843]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>markdown编辑器</tag>
        <tag>markdown语法</tag>
        <tag>图床</tag>
      </tags>
  </entry>
</search>
